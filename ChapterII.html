<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sample Website</title>
  <link rel="stylesheet" href="/src/output.css" />
</head>
<body class="flex flex-wrap content-start flex-row bg-[#f5f5dd] min-h-screen overflow-x-hidden">

  <!-- HEADER -->
  <header
  class="bg-[#C8AE7E] bg-opacity-90 header">

  <!-- LEFT SIDE: Logo + Title -->
  <div class="flex items-center space-x-3">
    <a href="/" class="flex items-center space-x-3" aria-label="Home">
      <img src="/Pictures/software-development.png" alt="Logo"
           class="w-7 h-7 sm:w-9 sm:h-9 md:w-11 md:h-11 lg:w-12 lg:h-12 xl:w-14 xl:h-14 object-contain 
                  transition-transform duration-300 hover:scale-110" />
      <h1 class="text-base sm:text-lg md:text-2xl lg:text-3xl xl:text-4xl 
                 font-bold text-black whitespace-nowrap transition-transform duration-300 hover:scale-105">
        Software Engineering
      </h1>
    </a>
  </div>

  <!-- RIGHT SIDE: Chapter Navigation -->
  <nav class="relative mt-2 sm:mt-0" aria-label="Chapter Navigation">
    <details class="group">
      <summary
        class="list-none cursor-pointer select-none
               text-sm sm:text-base md:text-lg lg:text-xl xl:text-2xl
               font-bold text-black bg-[#c3b091] rounded-xl
               px-3 sm:px-4 md:px-5 py-1 sm:py-1.5 
               shadow-black shadow-sm whitespace-nowrap
               hover:bg-[#b89f7a] transition-all duration-300 hover:scale-105">
        Chapter 2
      </summary>

      <ul
        class="absolute right-0 mt-2 bg-[#fdfaf3] rounded-lg shadow-md border border-gray-300
               text-black tracking-widest font-medium
               group-open:block hidden 
               min-w-56 sm:min-w-[16rem] md:min-w-[18rem] lg:min-w-[20rem]
               px-2 py-2 
               whitespace-nowrap overflow-hidden z-50">
        <li><a href="#SoftwareP" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md transition-colors duration-200">2.0 Software Process</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.1 Software Process Models</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.1.1 The Waterfall Development</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.1.2 Incremental Development</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.1.3 Reuse-Oriented Software Engineering</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.2 Process Activities</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.2.1 Software Specification</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.2.2 Software Design and Implementation</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.2.3 Software Validation</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.2.4 Software Evolution</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.3 Coping With Change</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.3.1 Prototyping</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.3.2 Incremental Delivery</a></li>
        <li><a href="#" class="block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.3.3 The Boehm's Spiral Model</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">2.4 The Rational Unified Process</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">Keypoints</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">Further Readings</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">Exercises</a></li>
        <li><a href="#" class="font-bold block px-4 py-2 hover:bg-[#c3b091] rounded-md">References</a></li>
      </ul>
    </details>
  </nav>
</header>


  <!-- MAIN CONTENT AREA (Empty for now) -->
  <main class="flex-1 p-4 text-[#996515]">
    <section>
      <h1 class="mt-1 text-xl font-bold tracking-widest pt-15 sm:pt-20 md:pt-22 lg:pt-25 xl:pt-28" id="SoftwareP">2.0 Software Processes</h1>
      <article class="tracking-widest p-3 indent-8 text-justify">
        <p>A software process is a set of related activities that leads to the production of a software product. These activities may involve the development of software from scratch
in a standard programming language like Java or C. However, business applications
are not necessarily developed in this way. New business software is now often developed by extending and modifying existing systems or by configuring and integrating
off-the-shelf software or system components.</p>
        <br><p>There are many different software processes but all must include four activities
that are fundamental to software engineering:</p>
      </article>
      <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            <strong>Software specification:</strong> The functionality of the software and constraints on its
            operation must be defined.</li>
        <li>
            <strong>Software design and implementation:</strong> The software to meet the specification
            must be produced.</li>
        <li>
            <strong>Software validation:</strong> The software must be validated to ensure that it does what
            the customer wants.</li>
        <li>
            <strong>Software evolution:</strong> The software must evolve to meet changing customer needs.</li>
        </ol>
      </article>
      <article class="tracking-widest p-3 indent-8 text-justify">
            <p>In some form, these activities are part of all software processes. In practice, of
    course, they are complex activities in themselves and include sub-activities such as
    requirements validation, architectural design, unit testing, etc. There are also supporting process activities
    such as documentation and software configuration management.</p>
            <br><p>When we describe and discuss processes, we usually talk about the activities in
        these processes such as specifying a data model, designing a user interface, etc., and
        the ordering of these activities. However, as well as activities, process descriptions
        may also include:</p>
      </article>
      <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            Products, which are the outcomes of a process activity. For example, the outcome of the activity of architectural design may be a model of the software
            architecture.
            </li>
        <li>
            Roles, which reflect the responsibilities of the people involved in the process.
            Examples of roles are project manager, configuration manager, programmer, etc.</li>
        <li>
            Pre- and post-conditions, which are statements that are true before and after a
            process activity has been enacted or a product produced. For example, before
            architectural design begins, a pre-condition may be that all requirements have
            been approved by the customer; after this activity is finished, a post-condition
            might be that the UML models describing the architecture have been reviewed.</li>
        </ol>
      </article>
      <article class="tracking-widest p-3 indent-8 text-justify">
            <p>Software processes are complex and, like all intellectual and creative processes,
            rely on people making decisions and judgments. There is no ideal process and most
            organizations have developed their own software development processes. Processes
            have evolved to take advantage of the capabilities of the people in an organization
            and the specific characteristics of the systems that are being developed.</p>
            <br><p>For some systems, such as critical systems, a very structured development process is required.
            For business systems, with rapidly changing requirements, a less formal, flexible
            process is likely to be more effective.
            </p>
            <br><p>Sometimes, software processes are categorized as either plan-driven or agile
            processes. Plan-driven processes are processes where all of the process activities are
            planned in advance and progress is measured against this plan. In agile processes,
            which I discuss in Chapter 3, planning is incremental and it is easier to change the
            process to reflect changing customer requirements. <br><br>As Boehm and Turner (2003)
            discuss, each approach is suitable for different types of software. Generally, you
            need to find a balance between plan-driven and agile processes.</p>
            <br><p>Although there is no ‘ideal’ software process, there is scope for improving the
            software process in many organizations. Processes may include outdated techniques
            or may not take advantage of the best practice in industrial software engineering.
            Indeed, many organizations still do not take advantage of software engineering
            methods in their software development.</p>
            <br><p>Software processes can be improved by process standardization where the diversity in software processes across an organization is reduced. This leads to improved
            communication and a reduction in training time, and makes automated process support more economical. Standardization is also an important first step in introducing
            new software engineering methods and techniques and good software engineering
            practice. I discuss software process improvement in more detail in Chapter 26.</p>
      </article>
    </section>
        <h1 class="mt-1 text-xl font-bold tracking-widest pt-3">2.1 Software Process Models</h1>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>As I explained in Chapter 1, a software process model is a simplified representation
            of a software process. Each process model represents a process from a particular perspective, and thus provides only partial information about that process. For example,
            a process activity model shows the activities and their sequence but may not show
            the roles of the people involved in these activities. In this section, I introduce a number of very general process models (sometimes called ‘process paradigms’) and
            present these from an architectural perspective. That is, we see the framework of the
            process but not the details of specific activities.</p>
            <br><p>These generic models are not definitive descriptions of software processes. Rather,
            they are abstractions of the process that can be used to explain different approaches to
            software development. You can think of them as process frameworks that may be
            extended and adapted to create more specific software engineering processes.</p>
            <br><p class="indent-0">The process models that I cover here are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            The <strong>Waterfall Model</strong> This takes the fundamental process activities of specification, development, validation, and evolution and represents them as separate
            process phases such as requirements specification, software design, implementation, testing, and so on.</li>
        <li>
            <strong>Incremental Development</strong> This approach interleaves the activities of specification, development, and validation. The system is developed as a series of versions
            (increments), with each version adding functionality to the previous version.</li>
        <li>
            <strong>Reuse-oriented Software Engineering</strong> This approach is based on the existence of
            a significant number of reusable components. The system development process
            focuses on integrating these components into a system rather than developing
            them from scratch.</li>
        </ol>
      </article>
      <article class="tracking-widest p-3 indent-8 text-justify">
        <p>These models are not mutually exclusive and are often used together, especially
            for large systems development. For large systems, it makes sense to combine some
            of the best features of the waterfall and the incremental development models. <br>You
            need to have information about the essential system requirements to design a software architecture to support these requirements. You cannot develop this incrementally. Sub-systems within a larger system may be developed using different
            approaches. <br>Parts of the system that are well understood can be specified and developed using a waterfall-based process. Parts of the system which are difficult to
            specify in advance, such as the user interface, should always be developed using an
            incremental approach.</p>
      </article>
      <section>
        <h1 class="mt-1 text-xl font-bold tracking-widest pt-15" id="SoftwareP">2.1.1 The Waterfall Model</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/waterfall.png" 
            alt="Software Process Diagram"
            class="w-[450px] h-[200px]  md:w-[600px] md:h-[250px] lg:w-[680px] lg:h-[280px] xl:w-[720px] xl:h-[310px] object-cover rounded-xl shadow-md shadow-gray-500 border border-[#b89f7a]
                    transition-transform duration-500 ease-in-out hover:scale-110 hover:shadow-xl hover:shadow-[#b89f7a]" />
        </article>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>The first published model of the software development process was derived from
                more general system engineering processes (Royce, 1970). This model is illustrated
                in Figure 2.1. Because of the cascade from one phase to another, this model is known
                as the ‘waterfall model’ or software life cycle. <br><br>The waterfall model is an example of
                a plan-driven process—in principle, you must plan and schedule all of the process
                activities before starting work on them.</p>
            <br><p class="indent-0">The principal stages of the waterfall model directly reflect the fundamental development activities:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            <strong>Requirements analysis and definition</strong> The system’s services, constraints, and
            goals are established by consultation with system users. They are then defined
            in detail and serve as a system specification.</li>
        <li>
            <strong>System and software design</strong> The systems design process allocates the requirements to either hardware or software systems by establishing an overall system
            architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.</li>
        <li>
            <strong>Implementation and unit testing</strong> During this stage, the software design is realized as a set of programs or program units. Unit testing involves verifying that
            each unit meets its specification.</li>
        <li>
            <strong>Integration and system testing</strong> The individual program units or programs
            are integrated and tested as a complete system to ensure that the software
            requirements have been met. After testing, the software system is delivered to
            the customer.</li>
        <li>
            <strong>Operation and maintenance</strong> Normally (although not necessarily), this is the
            longest life cycle phase. The system is installed and put into practical use.
            Maintenance involves correcting errors which were not discovered in earlier
            stages of the life cycle, improving the implementation of system units and
            enhancing the system’s services as new requirements are discovered.</li>
        </ol>
      </article>
      <article class="tracking-widest p-3 indent-8 text-justify">
            <p>The waterfall model is consistent with other engineering process models and documentation is produced at each phase. This makes the process visible so managers can
            monitor progress against the development plan. Its major problem is the inflexible partitioning of the project into distinct stages. Commitments must be made at an early stage
            in the process, which makes it difficult to respond to changing customer requirements.</p>
      </article>
    </section>
    <section>
        <h1 class="mt-1 text-xl font-bold tracking-widest pt-3">2.1.2 Incremental Development</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Incremental.png" 
            alt="Software Process Diagram"
            class="w-[450px] h-[180px]  md:w-[600px] md:h-[250px] lg:w-[680px] lg:h-[280px] xl:w-[720px] xl:h-[300px] object-cover rounded-xl shadow-md shadow-gray-500 border border-[#b89f7a]
                    transition-transform duration-500 ease-in-out hover:scale-110 hover:shadow-xl hover:shadow-[#b89f7a]" />
        </article>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>Incremental development is based on the idea of developing an initial implementation, exposing this to user comment and evolving it through several versions until an
            adequate system has been developed (Figure 2.2). Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across
            activities.</p>
            <br><p>Incremental software development, which is a fundamental part of agile
            approaches, is better than a waterfall approach for most business, e-commerce, and
            personal systems. Incremental development reflects the way that we solve problems. <br><br>We rarely work out a complete problem solution in advance but move toward
            a solution in a series of steps, backtracking when we realize that we have made a
            mistake. By developing the software incrementally, it is cheaper and easier to make
            changes in the software as it is being developed.</p>
            <br><p>Each increment or version of the system incorporates some of the functionality
            that is needed by the customer. Generally, the early increments of the system include
            the most important or most urgently required functionality. This means that the
            customer can evaluate the system at a relatively early stage in the development to see
            if it delivers what is required. If not, then only the current increment has to be
            changed and, possibly, new functionality defined for later increments.</p>
            <br><p class="indent-0">Incremental development has three important benefits, compared to the waterfall
            model:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            The cost of accommodating changing customer requirements is reduced. The
            amount of analysis and documentation that has to be redone is much less than is
            required with the waterfall model.</li>
        <li>
            It is easier to get customer feedback on the development work that has been
            done. Customers can comment on demonstrations of the software and see how
            much has been implemented. Customers find it difficult to judge progress from
            software design documents.</li>
        <li>
            More rapid delivery and deployment of useful software to the customer is possible, even if all of the functionality has not been included. Customers are able to
            use and gain value from the software earlier than is possible with a waterfall
            process.</li>
        </ol>
        </article>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>Incremental development in some form is now the most common approach for the
            development of application systems. This approach can be either plan-driven, agile,
            or, more usually, a mixture of these approaches. In a plan-driven approach, the system
            increments are identified in advance; if an agile approach is adopted, the early increments are identified but the development of later increments depends on progress and
            customer priorities.</p>
            <br><p class="indent-0">From a management perspective, the incremental approach has two problems:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            The process is not visible. Managers need regular deliverables to measure
            progress. If systems are developed quickly, it is not cost-effective to produce
            documents that reflect every version of the system.</li>
        <li>
            System structure tends to degrade as new increments are added. Unless time and
            money is spent on refactoring to improve the software, regular change tends to
            corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly.</li>
        </ol>
        </article>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>The problems of incremental development become particularly acute for large,
            complex, long-lifetime systems, where different teams develop different parts of the
            system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined
            with respect to that architecture. This has to be planned in advance rather than developed incrementally.</p>
            <br><p>You can develop a system incrementally and expose it to customers for comment,
            without actually delivering it and deploying it in the customer’s environment.
            Incremental delivery and deployment means that the software is used in real, operational processes. This is not always possible as experimenting with new software can
            disrupt normal business processes. I discuss the advantages and disadvantages of incremental delivery in Section 2.3.2.</p>
        </article>
    </section>
    <section>
        <h1 class="mt-1 text-xl font-bold tracking-widest pt-3">2.1.3 Reuse-oriented Software Engineering</h1>
        <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/reuse.png" 
            alt="Software Process Diagram"
            class="w-[450px] h-[130px] object-cover rounded-xl shadow-md shadow-gray-500 border border-[#b89f7a]
                    transition-transform duration-500 ease-in-out hover:scale-110 hover:shadow-xl hover:shadow-[#b89f7a]" />
        </article>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>In the majority of software projects, there is some software reuse. This often happens
            informally when people working on the project know of designs or code that are
            similar to what is required. They look for these, modify them as needed, and incorporate them into their system.</p>
            <br><p>This informal reuse takes place irrespective of the development process that is
            used. However, in the 21st century, software development processes that focus on the
            reuse of existing software have become widely used. Reuse-oriented approaches rely
            on a large base of reusable software components and an integrating framework for
            the composition of these components. Sometimes, these components are systems in
            their own right (COTS or commercial off-the-shelf systems) that may provide specific functionality such as word processing or a spreadsheet.</p>
            <br><p>A general process model for reuse-based development is shown in Figure 2.3.
            Although the initial requirements specification stage and the validation stage are
            comparable with other software processes, the intermediate stages in a reuseoriented process are different.</p>
            <br><p class="indent-0">These stages are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            Component analysis Given the requirements specification, a search is made for
            components to implement that specification. Usually, there is no exact match and
            the components that may be used only provide some of the functionality required.</li>
        <li>
            Requirements modification During this stage, the requirements are analyzed using
            information about the components that have been discovered. They are then modified to reflect the available components. Where modifications are impossible, the
            component analysis activity may be re-entered to search for alternative solutions.</li>
        <li>
            System design with reuse During this phase, the framework of the system is
            designed or an existing framework is reused. The designers take into account the
            components that are reused and organize the framework to cater for this. Some
            new software may have to be designed if reusable components are not available.</li>
        <li>
            Development and integration Software that cannot be externally procured is
            developed, and the components and COTS systems are integrated to create the
            new system. System integration, in this model, may be part of the development
            process rather than a separate activity.</li>
        </ol>
        </article>
        <article class="tracking-widest p-3 text-justify">
            <p>There are three types of software component that may be used in a reuse-oriented process:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="list-decimal list-inside space-y-2 text-justify">
        <li>
            Web services that are developed according to service standards and which are
            available for remote invocation.</li>
        <li>
            Collections of objects that are developed as a package to be integrated with a
            component framework such as .NET or J2EE.</li>
        <li>
            Stand-alone software systems that are configured for use in a particular
            environment.</li>
        </ol>
        </article>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>Reuse-oriented software engineering has the obvious advantage of reducing the
            amount of software to be developed and so reducing cost and risks. It usually also
            leads to faster delivery of the software. However, requirements compromises are
            inevitable and this may lead to a system that does not meet the real needs of users.
            Furthermore, some control over the system evolution is lost as new versions of the
            reusable components are not under the control of the organization using them.</p>
            <br><p>Software reuse is very important and I have dedicated several chapters in the third
            part of the book to this topic. General issues of software reuse and COTS reuse are
            covered in Chapter 16, component-based software engineering in Chapters 17 and
            18, and service-oriented systems in Chapter 19.</p>
        </article>
    </section>
    <section>
        <h1 class="mt-1 text-xl font-bold tracking-widest pt-3">2.2 Process Activities</h1>
        <article class="tracking-widest p-3 indent-8 text-justify">
            <p>Real software processes are interleaved sequences of technical, collaborative, and
            managerial activities with the overall goal of specifying, designing, implementing,
            and testing a software system. <br><br>Software developers use a variety of different software
            tools in their work. Tools are particularly useful for supporting the editing of different
            types of document and for managing the immense volume of detailed information
            that is generated in a large software project.</p>
            <br><p>The four basic process activities of specification, development, validation, and evolution are organized differently in different development processes. In the waterfall
            model, they are organized in sequence, whereas in incremental development they are
            interleaved. <br><br>How these activities are carried out depends on the type of software,
            people, and organizational structures involved. In extreme programming, for example,
            specifications are written on cards. Tests are executable and developed before the
            program itself. Evolution may involve substantial system restructuring or refactoring.</p>
        </article>
    </section>
  </main>

<!-- FOOTER -->
<footer class="w-full text-center py-4 text-gray-700 bg-[#C8AE7E] bg-opacity-80 mt-auto flex flex-col items-center space-y-3 sm:space-y-4 md:space-y-5">
  <div class="flex flex-wrap justify-center items-center gap-5 sm:gap-6 md:gap-8 lg:gap-10 xl:gap-12">

    <!-- Facebook -->
    <a href="https://www.facebook.com/erick.carenan.1/" target="_blank" aria-label="Facebook">
      <img src="/Pictures/facebook.png" alt="Facebook"
        class="w-7 h-7 sm:w-8 sm:h-8 md:w-9 md:h-9 lg:w-10 lg:h-10 xl:w-11 xl:h-11
               transform transition-transform duration-300 hover:scale-125 hover:opacity-80">
    </a>

    <!-- Instagram -->
    <a href="https://www.instagram.com/erckcrnn?igsh=cGU0MHhmN2t6b2d4" target="_blank" aria-label="Instagram">
      <img src="/Pictures/instagram.png" alt="Instagram"
        class="w-7 h-7 sm:w-8 sm:h-8 md:w-9 md:h-9 lg:w-10 lg:h-10 xl:w-11 xl:h-11
               transform transition-transform duration-300 hover:scale-125 hover:opacity-80">
    </a>

    <!-- Email -->
    <a href="mailto:23-14945@g.batstate-u.edu.ph" aria-label="Email">
      <img src="/Pictures/mail.png" alt="Email"
        class="w-7 h-7 sm:w-8 sm:h-8 md:w-9 md:h-9 lg:w-10 lg:h-10 xl:w-11 xl:h-11
               transform transition-transform duration-300 hover:scale-125 hover:opacity-80">
    </a>

    <!-- Telephone -->
    <a href="tel:+63XXXXXXXXXX" aria-label="Telephone">
      <img src="/Pictures/telephone.png" alt="Telephone"
        class="w-7 h-7 sm:w-8 sm:h-8 md:w-9 md:h-9 lg:w-10 lg:h-10 xl:w-11 xl:h-11
               transform transition-transform duration-300 hover:scale-125 hover:opacity-80">
    </a>
  </div>

  <p class="text-xs sm:text-sm md:text-base lg:text-lg xl:text-xl text-gray-800 font-medium tracking-wide">
    © 2025 Software Engineering. All rights reserved.
  </p>
</footer>




</body>
</html>
