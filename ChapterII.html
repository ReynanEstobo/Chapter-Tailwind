<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sample Website</title>
  <link rel="stylesheet" href="/src/output.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sour+Gummy:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
</head>
<body class="c2body">

  <header
  class="c2header bg-[#C8AE7E] bg-opacity-90">

  <div class="flex items-center space-x-3">
    <a href="/" class="flex items-center space-x-3" aria-label="Home">
      <img src="/Pictures/software-development.png" alt="Logo"
           class="c2logo" />
      <h1 class="c2title sour-gummy">
        Software Engineering
      </h1>
    </a>
  </div>

  <nav class="relative mt-2 sm:mt-0" aria-label="Chapter Navigation">
    <details class="group">
      <summary
        class="c2chapter2 sour-gummy">
        Chapter 2
      </summary>

      <ul
        class="c2ul sour-gummy">
        <li><a href="#SoftwareP" class="font-bold c2list">2.0 Software Process</a></li>
        <li><a href="#SoftwarePM" class="font-bold c2list">2.1 Software Process Models</a></li>
        <li><a href="#Waterfall" class="c2list">2.1.1 The Waterfall Development</a></li>
        <li><a href="#Incremental" class="c2list">2.1.2 Incremental Development</a></li>
        <li><a href="#Reuse" class="c2list">2.1.3 Reuse-Oriented Software Engineering</a></li>
        <li><a href="#Activities" class="font-bold c2list">2.2 Process Activities</a></li>
        <li><a href="#SoftwareSpec" class="c2list">2.2.1 Software Specification</a></li>
        <li><a href="#SoftwareDI" class="c2list">2.2.2 Software Design and Implementation</a></li>
        <li><a href="#SoftwareV" class="c2list">2.2.3 Software Validation</a></li>
        <li><a href="#SoftwareE" class="c2list">2.2.4 Software Evolution</a></li>
        <li><a href="#Coping" class="font-bold c2list">2.3 Coping With Change</a></li>
        <li><a href="#Proto" class="c2list">2.3.1 Prototyping</a></li>
        <li><a href="#IncreD" class="c2list">2.3.2 Incremental Delivery</a></li>
        <li><a href="#Boehm's" class="c2list">2.3.3 The Boehm's Spiral Model</a></li>
        <li><a href="#RationalUP" class="font-bold c2list">2.4 The Rational Unified Process</a></li>
        <li><a href="#Key" class="font-bold c2list">Keypoints</a></li>
        <li><a href="#FR" class="font-bold c2list">Further Readings</a></li>
        <li><a href="#Exercises" class="font-bold c2list">Exercises</a></li>
        <li><a href="#Ref" class="font-bold c2list">References</a></li>
      </ul>
    </details>
  </nav>
</header>

  <main class="flex-1 p-4 text-[#996515] sm:pl-9 sm:pr-9 md:pl-12 md:pr-12 lg:pl-15 lg:pr-15">
    <section>
      <h1 class="c2h1 sour-gummy" id="SoftwareP">2.0 Software Processes</h1>
      <article class="c2text sour-gummy">
        <p>A <strong>Software Process</strong> is a set of related activities that leads to the production of a software product. These activities may involve the development of software from scratch
in a standard programming language like Java or C. However, business applications
are not necessarily developed in this way. New business software is now often developed by extending and modifying existing systems or by configuring and integrating
off-the-shelf software or system components.</p>
        <br><p>There are many different software processes but all must include four activities
that are fundamental to software engineering:</p>
      </article>
      <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Software specification:</strong> The functionality of the software and constraints on its
            operation must be defined.</li>
        <li>
            <strong>Software design and implementation:</strong> The software to meet the specification
            must be produced.</li>
        <li>
            <strong>Software validation:</strong> The software must be validated to ensure that it does what
            the customer wants.</li>
        <li>
            <strong>Software evolution:</strong> The software must evolve to meet changing customer needs.</li>
        </ol>
      </article>
      <article class="c2text sour-gummy">
            <p>In some form, these activities are part of all software processes. In practice, of
    course, they are complex activities in themselves and include sub-activities such as
    requirements validation, architectural design, unit testing, etc. There are also supporting process activities
    such as documentation and software configuration management.</p>
            <br><p>When we describe and discuss processes, we usually talk about the activities in
        these processes such as specifying a data model, designing a user interface, etc., and
        the ordering of these activities. However, as well as activities, process descriptions
        may also include:</p>
      </article>
      <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Products</strong>, which are the outcomes of a process activity. For example, the outcome of the activity of architectural design may be a model of the software
            architecture.
            </li>
        <li>
            <strong>Roles</strong>, which reflect the responsibilities of the people involved in the process.
            Examples of roles are project manager, configuration manager, programmer, etc.</li>
        <li>
            <strong>Pre- and post-conditions</strong>, which are statements that are true before and after a
            process activity has been enacted or a product produced. For example, before
            architectural design begins, a pre-condition may be that all requirements have
            been approved by the customer; after this activity is finished, a post-condition
            might be that the UML models describing the architecture have been reviewed.</li>
        </ol>
      </article>
      <article class="c2text sour-gummy">
            <p><strong>Software processes</strong> are complex and, like all intellectual and creative processes,
            rely on people making decisions and judgments. There is no ideal process and most
            organizations have developed their own software development processes. Processes
            have evolved to take advantage of the capabilities of the people in an organization
            and the specific characteristics of the systems that are being developed.</p>
            <br><p>For some systems, such as critical systems, a very structured development process is required.
            For business systems, with rapidly changing requirements, a less formal, flexible
            process is likely to be more effective.
            </p>
            <br><p>Sometimes, software processes are categorized as either plan-driven or agile
            processes. Plan-driven processes are processes where all of the process activities are
            planned in advance and progress is measured against this plan. In agile processes,
            which I discuss in Chapter 3, planning is incremental and it is easier to change the
            process to reflect changing customer requirements. <br><br><strong>As Boehm and Turner (2003)</strong>
            discuss, each approach is suitable for different types of software. Generally, you
            need to find a balance between plan-driven and agile processes.</p>
            <br><p>Although there is no ‘ideal’ software process, there is scope for improving the
            software process in many organizations. Processes may include outdated techniques
            or may not take advantage of the best practice in industrial software engineering.
            Indeed, many organizations still do not take advantage of software engineering
            methods in their software development.</p>
            <br><p>Software processes can be improved by process standardization where the diversity in software processes across an organization is reduced. This leads to improved
            communication and a reduction in training time, and makes automated process support more economical. Standardization is also an important first step in introducing
            new software engineering methods and techniques and good software engineering
            practice. I discuss software process improvement in more detail in Chapter 26.</p>
      </article>
    </section>
        <h1 class="c2h12 sour-gummy" id="SoftwarePM">2.1 Software Process Models</h1>
        <article class="c2text sour-gummy">
            <p>As I explained in Chapter 1, a software process model is a simplified representation
            of a software process. Each process model represents a process from a particular perspective, and thus provides only partial information about that process. For example,
            a process activity model shows the activities and their sequence but may not show
            the roles of the people involved in these activities. In this section, I introduce a number of very general process models (sometimes called ‘process paradigms’) and
            present these from an architectural perspective. That is, we see the framework of the
            process but not the details of specific activities.</p>
            <br><p>These generic models are not definitive descriptions of software processes. Rather,
            they are abstractions of the process that can be used to explain different approaches to
            software development. You can think of them as process frameworks that may be
            extended and adapted to create more specific software engineering processes.</p>
            <br><p class="indent-0">The process models that I cover here are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            The <strong>Waterfall Model</strong> This takes the fundamental process activities of specification, development, validation, and evolution and represents them as separate
            process phases such as requirements specification, software design, implementation, testing, and so on.</li>
        <li>
            <strong>Incremental Development</strong> This approach interleaves the activities of specification, development, and validation. The system is developed as a series of versions
            (increments), with each version adding functionality to the previous version.</li>
        <li>
            <strong>Reuse-oriented Software Engineering</strong> This approach is based on the existence of
            a significant number of reusable components. The system development process
            focuses on integrating these components into a system rather than developing
            them from scratch.</li>
        </ol>
      </article>
      <article class="c2text sour-gummy">
        <p>These models are not mutually exclusive and are often used together, especially
            for large systems development. For large systems, it makes sense to combine some
            of the best features of the waterfall and the incremental development models. <br>You
            need to have information about the essential system requirements to design a software architecture to support these requirements. You cannot develop this incrementally. Sub-systems within a larger system may be developed using different
            approaches. <br>Parts of the system that are well understood can be specified and developed using a waterfall-based process. Parts of the system which are difficult to
            specify in advance, such as the user interface, should always be developed using an
            incremental approach.</p>
      </article>
      <section>
        <h1 class="c2h12 sour-gummy" id="Waterfall">2.1.1 The Waterfall Model</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/waterfall.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
            <p>The first published model of the software development process was derived from
                more general system engineering processes (Royce, 1970). This model is illustrated
                in Figure 2.1. Because of the cascade from one phase to another, this model is known
                as the ‘waterfall model’ or software life cycle. <br><br>The waterfall model is an example of
                a plan-driven process—in principle, you must plan and schedule all of the process
                activities before starting work on them.</p>
            <br><p class="indent-0">The principal stages of the waterfall model directly reflect the fundamental development activities:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Requirements analysis and definition</strong> The system’s services, constraints, and
            goals are established by consultation with system users. They are then defined
            in detail and serve as a system specification.</li>
        <li>
            <strong>System and software design</strong> The systems design process allocates the requirements to either hardware or software systems by establishing an overall system
            architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.</li>
        <li>
            <strong>Implementation and unit testing</strong> During this stage, the software design is realized as a set of programs or program units. Unit testing involves verifying that
            each unit meets its specification.</li>
        <li>
            <strong>Integration and system testing</strong> The individual program units or programs
            are integrated and tested as a complete system to ensure that the software
            requirements have been met. After testing, the software system is delivered to
            the customer.</li>
        <li>
            <strong>Operation and maintenance</strong> Normally (although not necessarily), this is the
            longest life cycle phase. The system is installed and put into practical use.
            Maintenance involves correcting errors which were not discovered in earlier
            stages of the life cycle, improving the implementation of system units and
            enhancing the system’s services as new requirements are discovered.</li>
        </ol>
      </article>
      <article class="c2text sour-gummy">
            <p>The waterfall model is consistent with other engineering process models and documentation is produced at each phase. This makes the process visible so managers can
            monitor progress against the development plan. Its major problem is the inflexible partitioning of the project into distinct stages. Commitments must be made at an early stage
            in the process, which makes it difficult to respond to changing customer requirements.</p>
      </article>
    </section>
    <section>
        <h1 class="c2h12 sour-gummy" id="Incremental">2.1.2 Incremental Development</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/incremental.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
            <p>Incremental development is based on the idea of developing an initial implementation, exposing this to user comment and evolving it through several versions until an
            adequate system has been developed (Figure 2.2). Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across
            activities.</p>
            <br><p>Incremental software development, which is a fundamental part of agile
            approaches, is better than a waterfall approach for most business, e-commerce, and
            personal systems. Incremental development reflects the way that we solve problems. <br><br>We rarely work out a complete problem solution in advance but move toward
            a solution in a series of steps, backtracking when we realize that we have made a
            mistake. By developing the software incrementally, it is cheaper and easier to make
            changes in the software as it is being developed.</p>
            <br><p>Each increment or version of the system incorporates some of the functionality
            that is needed by the customer. Generally, the early increments of the system include
            the most important or most urgently required functionality. This means that the
            customer can evaluate the system at a relatively early stage in the development to see
            if it delivers what is required. If not, then only the current increment has to be
            changed and, possibly, new functionality defined for later increments.</p>
            <br><p class="indent-0">Incremental development has three important benefits, compared to the waterfall
            model:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            The cost of accommodating changing customer requirements is reduced. The
            amount of analysis and documentation that has to be redone is much less than is
            required with the waterfall model.</li>
        <li>
            It is easier to get customer feedback on the development work that has been
            done. Customers can comment on demonstrations of the software and see how
            much has been implemented. Customers find it difficult to judge progress from
            software design documents.</li>
        <li>
            More rapid delivery and deployment of useful software to the customer is possible, even if all of the functionality has not been included. Customers are able to
            use and gain value from the software earlier than is possible with a waterfall
            process.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
            <p>Incremental development in some form is now the most common approach for the
            development of application systems. This approach can be either plan-driven, agile,
            or, more usually, a mixture of these approaches. In a plan-driven approach, the system
            increments are identified in advance; if an agile approach is adopted, the early increments are identified but the development of later increments depends on progress and
            customer priorities.</p>
            <br><p class="indent-0">From a management perspective, the incremental approach has two problems:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            The process is not visible. Managers need regular deliverables to measure
            progress. If systems are developed quickly, it is not cost-effective to produce
            documents that reflect every version of the system.</li>
        <li>
            System structure tends to degrade as new increments are added. Unless time and
            money is spent on refactoring to improve the software, regular change tends to
            corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
            <p>The problems of incremental development become particularly acute for large,
            complex, long-lifetime systems, where different teams develop different parts of the
            system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined
            with respect to that architecture. This has to be planned in advance rather than developed incrementally.</p>
            <br><p>You can develop a system incrementally and expose it to customers for comment,
            without actually delivering it and deploying it in the customer’s environment.
            Incremental delivery and deployment means that the software is used in real, operational processes. This is not always possible as experimenting with new software can
            disrupt normal business processes. I discuss the advantages and disadvantages of incremental delivery in Section 2.3.2.</p>
        </article>
    </section>
    <section>
        <h1 class="c2h12 sour-gummy" id="Reuse">2.1.3 Reuse-oriented Software Engineering</h1>
        <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/reuse.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
            <p>In the majority of software projects, there is some software reuse. This often happens
            informally when people working on the project know of designs or code that are
            similar to what is required. They look for these, modify them as needed, and incorporate them into their system.</p>
            <br><p>This informal reuse takes place irrespective of the development process that is
            used. However, in the 21st century, software development processes that focus on the
            reuse of existing software have become widely used. Reuse-oriented approaches rely
            on a large base of reusable software components and an integrating framework for
            the composition of these components. Sometimes, these components are systems in
            their own right (COTS or commercial off-the-shelf systems) that may provide specific functionality such as word processing or a spreadsheet.</p>
            <br><p>A general process model for reuse-based development is shown in Figure 2.3.
            Although the initial requirements specification stage and the validation stage are
            comparable with other software processes, the intermediate stages in a reuseoriented process are different.</p>
            <br><p class="indent-0">These stages are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            Component analysis Given the requirements specification, a search is made for
            components to implement that specification. Usually, there is no exact match and
            the components that may be used only provide some of the functionality required.</li>
        <li>
            Requirements modification During this stage, the requirements are analyzed using
            information about the components that have been discovered. They are then modified to reflect the available components. Where modifications are impossible, the
            component analysis activity may be re-entered to search for alternative solutions.</li>
        <li>
            System design with reuse During this phase, the framework of the system is
            designed or an existing framework is reused. The designers take into account the
            components that are reused and organize the framework to cater for this. Some
            new software may have to be designed if reusable components are not available.</li>
        <li>
            Development and integration Software that cannot be externally procured is
            developed, and the components and COTS systems are integrated to create the
            new system. System integration, in this model, may be part of the development
            process rather than a separate activity.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
            <p class="indent-0">There are three types of software component that may be used in a reuse-oriented process:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            Web services that are developed according to service standards and which are
            available for remote invocation.</li>
        <li>
            Collections of objects that are developed as a package to be integrated with a
            component framework such as .NET or J2EE.</li>
        <li>
            Stand-alone software systems that are configured for use in a particular
            environment.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
            <p>Reuse-oriented software engineering has the obvious advantage of reducing the
            amount of software to be developed and so reducing cost and risks. It usually also
            leads to faster delivery of the software. However, requirements compromises are
            inevitable and this may lead to a system that does not meet the real needs of users.
            Furthermore, some control over the system evolution is lost as new versions of the
            reusable components are not under the control of the organization using them.</p>
            <br><p>Software reuse is very important and I have dedicated several chapters in the third
            part of the book to this topic. General issues of software reuse and COTS reuse are
            covered in Chapter 16, component-based software engineering in Chapters 17 and
            18, and service-oriented systems in Chapter 19.</p>
        </article>
    </section>
    <section>
        <h1 class="c2h12 sour-gummy" id="Activities">2.2 Process Activities</h1>
        <article class="c2text sour-gummy">
            <p>Real software processes are interleaved sequences of technical, collaborative, and
            managerial activities with the overall goal of specifying, designing, implementing,
            and testing a software system. <br><br>Software developers use a variety of different software
            tools in their work. Tools are particularly useful for supporting the editing of different
            types of document and for managing the immense volume of detailed information
            that is generated in a large software project.</p>
            <br><p>The four basic process activities of specification, development, validation, and evolution are organized differently in different development processes. In the waterfall
            model, they are organized in sequence, whereas in incremental development they are
            interleaved. <br><br>How these activities are carried out depends on the type of software,
            people, and organizational structures involved. In extreme programming, for example,
            specifications are written on cards. Tests are executable and developed before the
            program itself. Evolution may involve substantial system restructuring or refactoring.</p>
        </article>
    </section>
    <section>
       <h1 class="c2h12 sour-gummy" id="SoftwareSpec">2.2.1 Software Specification</h1>
       <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/softwareSpec.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
       <article class="c2text sour-gummy">
        <p><strong>Software specification</strong> or requirements engineering is the process of understanding
        and defining what services are required from the system and identifying the constraints on the system’s operation and development. 
        <br><br><strong>Requirements engineering</strong> is a particularly critical stage of the software process as errors at this stage inevitably
        lead to later problems in the system design and implementation.</p>
        <br><p><strong>The requirements engineering process</strong> (Figure 2.4) aims to produce an agreed
        requirements document that specifies a system satisfying stakeholder requirements.
        <br><br><strong>Requirements</strong> are usually presented at two levels of detail. End-users and customers
        need a high-level statement of the requirements; system developers need a more
        detailed system specification.</p>
        <br><p class="indent-0">There are four main activities in the requirements engineering process:</p>
       </article>
       <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Feasibility Study</strong> - An estimate is made of whether the identified user needs may be
            satisfied using current software and hardware technologies. The study considers
            whether the proposed system will be cost-effective from a business point of view
            and if it can be developed within existing budgetary constraints. A feasibility
            study should be relatively cheap and quick. The result should inform the decision
            of whether or not to go ahead with a more detailed analysis.</li>
        <li>
            <strong>Requirements Elicitation and Analysis</strong> - This is the process of deriving the system
            requirements through observation of existing systems, discussions with potential users and procurers, task analysis, and so on. This may involve the development of one or more system models and prototypes. These help you understand
            the system to be specified.</li>
        <li>
            <strong>Requirements Specification</strong> - Requirements specification is the activity of translating the information gathered during the analysis activity into a document that defines a set of requirements. Two types of requirements may be included in this
            document. User requirements are abstract statements of the system requirements for the customer and end-user of the system; system requirements are a
            more detailed description of the functionality to be provided.</li>
        <li>
            <strong>Requirements Validation</strong> - This activity checks the requirements for realism, consistency, and completeness. During this process, errors in the requirements document
            are inevitably discovered. It must then be modified to correct these problems.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
            <p>Of course, the activities in the requirements process are not simply carried out in a
            strict sequence. Requirements analysis continues during definition and specification and
            new requirements come to light throughout the process. <br><br>Therefore, the activities of
            analysis, definition, and specification are interleaved. In agile methods, such as extreme
            programming, requirements are developed incrementally according to user priorities and
            the elicitation of requirements comes from users who are part of the development team.</p>
        </article>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="SoftwareDI">2.2.2 Software design and implementation</h1>
       <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/softwareImp.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>The implementation stage of software development is the process of converting a
          system specification into an executable system. It always involves processes of software design and programming but, if an incremental approach to development is
          used, may also involve refinement of the software specification.</p>
          <br><p>A software design is a description of the structure of the software to be implemented,
          the data models and structures used by the system, the interfaces between system components and, sometimes, the algorithms used. Designers do not arrive at a finished
          design immediately but develop the design iteratively. They add formality and detail as
          they develop their design with constant backtracking to correct earlier designs.</p>
          <br><p>Figure 2.5 is an abstract model of this process showing the inputs to the design
          process, process activities, and the documents produced as outputs from this process.</p>
          <br><p>The diagram suggests that the stages of the design process are sequential. In fact,
          design process activities are interleaved. Feedback from one stage to another and
          consequent design rework is inevitable in all design processes.</p>
          <br><p>Most software interfaces with other software systems. These include the operating
          system, database, middleware, and other application systems. These make up the ‘software platform’, the environment in which the software will execute. Information about
          this platform is an essential input to the design process, as designers must decide how
          best to integrate it with the software’s environment. <br><br>The requirements specification is a
          description of the functionality the software must provide and its performance and
          dependability requirements. If the system is to process existing data, then the description
          of that data may be included in the platform specification; otherwise, the data description
          must be an input to the design process so that the system data organization to be defined.</p>
          <br><p class="indent-0">The activities in the design process vary, depending on the type of system being
          developed. For example, real-time systems require timing design but may not
          include a database so there is no database design involved. Figure 2.5 shows four
          activities that may be part of the design process for information systems:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Architectural design</strong>, where you identify the overall structure of the system, the
            principal components (sometimes called sub-systems or modules), their relationships, and how they are distributed.</li>
        <li>
            <strong>Interface design</strong>, where you define the interfaces between system components.
            This interface specification must be unambiguous. With a precise interface, a
            component can be used without other components having to know how it is
            implemented. Once interface specifications are agreed, the components can be
            designed and developed concurrently.</li>
        <li>
            <strong>Component design</strong>, where you take each system component and design how it will
            operate. This may be a simple statement of the expected functionality to be
            implemented, with the specific design left to the programmer. Alternatively, it may
            be a c2list of changes to be made to a reusable component or a detailed design model.
            The design model may be used to automatically generate an implementation.</li>
        <li>
            <strong>Database design</strong>, where you design the system data structures and how these are
            to be represented in a database. Again, the work here depends on whether an
            existing database is to be reused or a new database is to be created.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>The development of a program to implement the system follows naturally from the
          system design processes. Although some classes of program, such as safety-critical
          systems, are usually designed in detail before any implementation begins, it is more
          common for the later stages of design and program development to be interleaved.
          <br><br>Software development tools may be used to generate a skeleton program from a
          design. This includes code to define and implement interfaces, and, in many cases, the
          developer need only add details of the operation of each program component.</p>
        </article>
        <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/testing.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>Normally, programmers carry out some testing of the code they have developed. This
          often reveals program defects that must be removed from the program. This is called
          debugging. Defect testing and debugging are different processes. <br><br>Testing establishes the
          existence of defects. Debugging is concerned with locating and correcting these defects.</p>
          <br><p>When you are debugging, you have to generate hypotheses about the observable
          behavior of the program then test these hypotheses in the hope of finding the fault that
          caused the output anomaly. <br><br>Testing the hypotheses may involve tracing the program
          code manually. It may require new test cases to localize the problem. Interactive
          debugging tools, which show the intermediate values of program variables and a trace
          of the statements executed, may be used to support the debugging process.</p>
        </article>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="SoftwareV">2.2.3 Software Validation</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Softwareval.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>Software validation or, more generally, verification and validation (V&V) is
          intended to show that a system both conforms to its specification and that it meets
          the expectations of the system customer. Program testing, where the system is executed using simulated test data, is the principal validation technique. 
          <br><br>Validation may also involve checking processes, such as inspections and reviews, at each stage of the
          software process from user requirements definition to program development.
          Because of the predominance of testing, the majority of validation costs are incurred
          during and after implementation.</p>
          <br><p>Except for small programs, systems should not be tested as a single, monolithic
          unit. Figure 2.6 shows a three-stage testing process in which system components are
          tested then the integrated system is tested and, finally, the system is tested with the
          customer’s data. Ideally, component defects are discovered early in the process, and
          interface problems are found when the system is integrated.</p>
          <br><p>However, as defects are
          discovered, the program must be debugged and this may require other stages in the
          testing process to be repeated. Errors in program components, say, may come to light
          during system testing. The process is therefore an iterative one with information
          being fed back from later stages to earlier parts of the process.</p>
          <p class="indent-0">The stages in the testing process are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Development testing</strong> The components making up the system are tested by the
            people developing the system. Each component is tested independently, without
            other system components. Components may be simple entities such as functions or object classes, or may be coherent groupings of these entities. Test automation tools, such as JUnit (Massol and Husted, 2003), that can re-run component
            tests when new versions of the component are created, are commonly used.</li>
        <li>
            <strong>System testing</strong> System components are integrated to create a complete system.
            This process is concerned with finding errors that result from unanticipated
            interactions between components and component interface problems. It is also
            concerned with showing that the system meets its functional and non-functional
            requirements, and testing the emergent system properties. For large systems,
            this may be a multi-stage process where components are integrated to form subsystems that are individually tested before these sub-systems are themselves
            integrated to form the final system.</li>
        <li>
            <strong>Acceptance testing</strong> This is the final stage in the testing process before the system
            is accepted for operational use. The system is tested with data supplied by the
            system customer rather than with simulated test data. Acceptance testing may
            reveal errors and omissions in the system requirements definition, because the
            real data exercise the system in different ways from the test data. Acceptance
            testing may also reveal requirements problems where the system’s facilities do
            not really meet the user’s needs or the system performance is unacceptable.</li>
        </ol>
        </article>
        <article>
          <p>Normally, component development and testing processes are interleaved.
          Programmers make up their own test data and incrementally test the code as it is
          developed. This is an economically sensible approach, as the programmer knows the
          component and is therefore the best person to generate test cases.</p>
          <br><p>If an incremental approach to development is used, each increment should be
          tested as it is developed, with these tests based on the requirements for that increment. In extreme programming, tests are developed along with the requirements
          before development starts. This helps the testers and developers to understand the
          requirements and ensures that there are no delays as test cases are created.</p>
          <br><p>When a plan-driven software process is used (e.g., for critical systems development), testing is driven by a set of test plans. An independent team of testers works
          from these pre-formulated test plans, which have been developed from the system
          specification and design. Figure 2.7 illustrates how test plans are the link between
          testing and development activities. This is sometimes called the V-model of development (turn it on its side to see the V).</p>
          <br><p>Acceptance testing is sometimes called ‘alpha testing’. Custom systems are
          developed for a single client. The alpha testing process continues until the system
          developer and the client agree that the delivered system is an acceptable implementation of the requirements.</p>
          <br><p>When a system is to be marketed as a software product, a testing process called
          ‘beta testing’ is often used. Beta testing involves delivering a system to a number of
          potential customers who agree to use that system. They report problems to the system developers. This exposes the product to real use and detects errors that may not
          have been anticipated by the system builders. After this feedback, the system is modified and released either for further beta testing or for general sale.</p>
        </article>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="SoftwareE">2.2.4 Software Evolution</h1>
      <article class="c2text sour-gummy">
        <p>The flexibility of software systems is one of the main reasons why more and more
        software is being incorporated in large, complex systems. Once a decision has been
        made to manufacture hardware, it is very expensive to make changes to the hardware
        design. However, changes can be made to software at any time during or after the
        system development. Even extensive changes are still much cheaper than corresponding changes to system hardware.</p>
        <br><p>Historically, there has always been a split between the process of software development and the process of software evolution (software maintenance). People think
        of software development as a creative activity in which a software system is developed from an initial concept through to a working system. However, they sometimes
        think of software maintenance as dull and uninteresting. Although the costs of maintenance are often several times the initial development costs, maintenance processes
        are sometimes considered to be less challenging than original software development.</p>
        <br><p>This distinction between development and maintenance is increasingly irrelevant.
        Hardly any software systems are completely new systems and it makes much more
        sense to see development and maintenance as a continuum. Rather than two separate
        processes, it is more realistic to think of software engineering as an evolutionary
        process (Figure 2.8) where software is continually changed over its lifetime in
        response to changing requirements and customer needs.</p>
      </article>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="Coping">2.3 Coping with Change</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Evolution.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>Change is inevitable in all large software projects. The system requirements change
          as the business procuring the system responds to external pressures and management
          priorities change. As new technologies become available, new design and implementation possibilities emerge. Therefore whatever software process model is used, it is
          essential that it can accommodate changes to the software being developed.</p>
          <br><p>Change adds to the costs of software development because it usually means that
          work that has been completed has to be redone. This is called rework. For example, if
          the relationships between the requirements in a system have been analyzed and new
          requirements are then identified, some or all of the requirements analysis has to be
          repeated. It may then be necessary to redesign the system to deliver the new requirements, change any programs that have been developed, and re-test the system.</p>
          <br><p class="indent-0">There are two related approaches that may be used to reduce the costs of rework:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Change avoidance</strong>, where the software process includes activities that can anticipate possible changes before significant rework is required. For example, a prototype system may be developed to show some key features of the system to
            customers. They can experiment with the prototype and refine their requirements before committing to high software production costs</li>
        <li>
            <strong>Change tolerance</strong>, where the process is designed so that changes can be accommodated at relatively low cost. This normally involves some form of incremental development. Proposed changes may be implemented in increments that
            have not yet been developed. If this is impossible, then only a single increment
            (a small part of the system) may have to be altered to incorporate the change.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p class="indent-0">In this section, I discuss two ways of coping with change and changing system
        requirements. These are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>System prototyping</strong>, where a version of the system or part of the system is developed
            quickly to check the customer’s requirements and the feasibility of some design
            decisions. This supports change avoidance as it allows users to experiment with the
            system before delivery and so refine their requirements. The number of requirements change proposals made after delivery is therefore likely to be reduced.</li>
        <li>
            <strong>Incremental delivery</strong>, where system increments are delivered to the customer for
            comment and experimentation. This supports both change avoidance and
            change tolerance. It avoids the premature commitment to requirements for the
            whole system and allows changes to be incorporated into later increments at relatively low cost.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>The notion of refactoring, namely improving the structure and organization of a
          program, is also an important mechanism that supports change tolerance. I discuss
          this in Chapter 3, which covers agile methods.</p>
        </article>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="Proto">2.3.1 Prototyping</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Proto.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>A prototype is an initial version of a software system that is used to demonstrate
          concepts, try out design options, and find out more about the problem and its possible solutions. Rapid, iterative development of the prototype is essential so that costs
          are controlled and system stakeholders can experiment with the prototype early in
          the software process.</p>
          <br><p class="indent-0">A software prototype can be used in a software development process to help
          anticipate changes that may be required:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
             In the requirements engineering process, a prototype can help with the elicitation and validation of system requirements.</li>
        <li>
            In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>System prototypes allow users to see how well the system supports their work.
          They may get new ideas for requirements, and find areas of strength and weakness in
          the software. <br><br>They may then propose new system requirements. Furthermore, as the
          prototype is developed, it may reveal errors and omissions in the requirements that
          have been proposed. <br><br>A function described in a specification may seem useful and well
          defined. However, when that function is combined with other functions, users often
          find that their initial view was incorrect or incomplete. The system specification may
          then be modified to reflect their changed understanding of the requirements</p>
          <br><p>A system prototype may be used while the system is being designed to carry out
          design experiments to check the feasibility of a proposed design. <br><br>For example, a
          database design may be prototyped and tested to check that it supports efficient data
          access for the most common user queries. <br><br>Prototyping is also an essential part of the
          user interface design process. Because of the dynamic nature of user interfaces, textual descriptions and diagrams are not good enough for expressing the user interface
          requirements. Therefore, rapid prototyping with end-user involvement is the only
          sensible way to develop graphical user interfaces for software systems.</p>
          <br><p>A process model for prototype development is shown in Figure 2.9. The objectives of prototyping should be made explicit from the start of the process. These may
          be to develop a system to prototype the user interface, to develop a system to validate
          functional system requirements, or to develop a system to demonstrate the feasibility of the application to managers. <br><br>The same prototype cannot meet all objectives. If the
          objectives are left unstated, management or end-users may misunderstand the function of the prototype. Consequently, they may not get the benefits that they expected
          from the prototype development.</p>
          <br><p>The next stage in the process is to decide what to put into and, perhaps more
          importantly, what to leave out of the prototype system. To reduce prototyping costs
          and accelerate the delivery schedule, you may leave some functionality out of the
          prototype. <br><br>You may decide to relax non-functional requirements such as response
          time and memory utilization. Error handling and management may be ignored unless
          the objective of the prototype is to establish a user interface. Standards of reliability
          and program quality may be reduced.</p>
          <br><p>The final stage of the process is prototype evaluation. Provision must be made
          during this stage for user training and the prototype objectives should be used to
          derive a plan for evaluation. Users need time to become comfortable with a new system and to settle into a normal pattern of usage. Once they are using the system normally, 
          they then discover requirements errors and omissions.</p>
          <br><p>A general problem with prototyping is that the prototype may not necessarily be
          used in the same way as the final system. The tester of the prototype may not be typical of system users. <br><br>The training time during prototype evaluation may be insufficient. If the prototype is slow, 
          the evaluators may adjust their way of working and avoid those system features that have slow response times. When provided with better response in the final system, they may use it in a different way.</p>
          <br><p class="indent-0">Developers are sometimes pressured by managers to deliver throwaway prototypes, particularly when there are delays in delivering the final version of the software. However, this is usually unwise:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            It may be impossible to tune the prototype to meet non-functional requirements,
            such as performance, security, robustness, and reliability requirements, which
            were ignored during prototype development.</li>
        <li>
            Rapid change during development inevitably means that the prototype is undocumented. The only design specification is the prototype code. This is not good
            enough for long-term maintenance.</li>
        <li>
            The changes made during prototype development will probably have degraded
            the system structure. The system will be difficult and expensive to maintain.</li>
        <li>
            Organizational quality standards are normally relaxed for prototype development.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>Prototypes do not have to be executable to be useful. Paper-based mock-ups of
          the system user interface (Rettig, 1994) can be effective in helping users refine an
          interface design and work through usage scenarios. <br><br>These are very cheap to develop
          and can be constructed in a few days. An extension of this technique is a Wizard of
          Oz prototype where only the user interface is developed. Users interact with this
          interface but their requests are passed to a person who interprets them and outputs
          the appropriate response.</p>
        </article>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="IncreD">2.3.2 Incremental delivery</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Incred.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>Incremental delivery (Figure 2.10) is an approach to software development where
          some of the developed increments are delivered to the customer and deployed for use
          in an operational environment. <br><br>In an incremental delivery process, customers identify, in outline, the services to be provided by the system. They identify which of the
          services are most important and which are least important to them. A number of
          delivery increments are then defined, with each increment providing a sub-set of the
          system functionality. The allocation of services to increments depends on the service
          priority, with the highest-priority services implemented and delivered first.</p>
          <br><p>Once the system increments have been identified, the requirements for the services to be delivered in the first increment are defined in detail and that increment is
          developed. During development, further requirements analysis for later increments
          can take place but requirements changes for the current increment are not accepted.</p>
          <br><p>Once an increment is completed and delivered, customers can put it into service.
          This means that they take early delivery of part of the system functionality. They can
          experiment with the system and this helps them clarify their requirements for later system increments. As new increments are completed, they are integrated with existing
          increments so that the system functionality improves with each delivered increment.</p>
          <br><p class="indent-0">Incremental delivery has a number of advantages:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            Customers can use the early increments as prototypes and gain experience that
            informs their requirements for later system increments. Unlike prototypes, these
            are part of the real system so there is no re-learning when the complete system is
            available.</li>
        <li>
            Customers do not have to wait until the entire system is delivered before they
            can gain value from it. The first increment satisfies their most critical requirements so they can use the software immediately.</li>
        <li>
             The process maintains the benefits of incremental development in that it should
             be relatively easy to incorporate changes into the system.</li>
        <li>
            As the highest-priority services are delivered first and increments then integrated, the most important system services receive the most testing. 
            This means that customers are less likely to encounter software failures in the most important parts of the system.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p class="indent-0">However, there are problems with incremental delivery:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            Most systems require a set of basic facilities that are used by different parts of the
            system. As requirements are not defined in detail until an increment is to be
            implemented, it can be hard to identify common facilities that are needed by all
            increments.</li>
        <li>
            Iterative development can also be difficult when a replacement system is being
            developed. Users want all of the functionality of the old system and are often
            unwilling to experiment with an incomplete new system. Therefore, getting useful customer feedback is difficult.</li>
        <li>
            The essence of iterative processes is that the specification is developed in conjunction with the software. However, this conflicts with the procurement model of
            many organizations, where the complete system specification is part of the system
            development contract. In the incremental approach, there is no complete system
            specification until the final increment is specified. This requires a new form of
            contract, which large customers such as government agencies may find difficult to
            accommodate.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>There are some types of system where incremental development and delivery is
          not the best approach. These are very large systems where development may involve
          teams working in different locations, some embedded systems where the software
          depends on hardware development and some critical systems where all the requirements must be analyzed to check for interactions that may compromise the safety or
          security of the system.</p>
          <br><p>These systems, of course, suffer from the same problems of uncertain and changing requirements. Therefore, to address these problems and get some of the benefits
          of incremental development, a process may be used in which a system prototype is
          developed iteratively and used as a platform for experiments with the system
          requirements and design. With the experience gained from the prototype, definitive
          requirements can then be agreed.</p>
        </article>
        <section>
          <h1 class="c2h12 sour-gummy" id="Boehm's">2.3.3 Boehm’s spiral model</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/boehm.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>A risk-driven software process framework (the spiral model) was proposed by
          Boehm (1988). This is shown in Figure 2.11. Here, the software process is represented as a spiral, rather than a sequence of activities with some backtracking from
          one activity to another. Each loop in the spiral represents a phase of the software
          process. <br><br>Thus, the innermost loop might be concerned with system feasibility, the
          next loop with requirements definition, the next loop with system design, and so on.
          The spiral model combines change avoidance with change tolerance. It assumes that changes are a result of project risks and includes explicit risk management activities
          to reduce these risks.</p>
          <br><p class="indent-0">Each loop in the spiral is split into four sectors:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Objective setting</strong> Specific objectives for that phase of the project are defined.
            Constraints on the process and the product are identified and a detailed management plan is drawn up. Project risks are identified. Alternative strategies,
            depending on these risks, may be planned.</li>
        <li>
            <strong>Risk assessment and reduction</strong> For each of the identified project risks, a detailed
            analysis is carried out. Steps are taken to reduce the risk. For example, if there is a
            risk that the requirements are inappropriate, a prototype system may be developed.</li>
        <li>
            <strong>Development and validation</strong> After risk evaluation, a development model for the
            system is chosen. For example, throwaway prototyping may be the best development approach if user interface risks are dominant. If safety risks are the main
            consideration, development based on formal transformations may be the most
            appropriate process, and so on. If the main identified risk is sub-system integration, the waterfall model may be the best development model to use.</li>
        <li>
            <strong>Planning</strong> The project is reviewed and a decision made whether to continue with
            a further loop of the spiral. If it is decided to continue, plans are drawn up for the
            next phase of the project.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>The main difference between the spiral model and other software process models is
          its explicit recognition of risk. A cycle of the spiral begins by elaborating objectives
          such as performance and functionality. Alternative ways of achieving these objectives, and dealing with the constraints on each of them, are then enumerated. Each
          alternative is assessed against each objective and sources of project risk are identified. The next step is to resolve these risks by information-gathering activities such
          as more detailed analysis, prototyping, and simulation.</p>
          <br><p>Once risks have been assessed, some development is carried out, followed by a planning activity for the next phase of the process. Informally, risk simply means something
          that can go wrong. For example, if the intention is to use a new programming language,
          a risk is that the available compilers are unreliable or do not produce sufficiently efficient object code. Risks lead to proposed software changes and project problems such as
          schedule and cost overrun, so risk minimization is a very important project management
          activity. Risk management, an essential part of project management, is covered in
          Chapter 22.</p>
        </article>
        </section>
    </section>
    <section>
      <h1 class="c2h12 sour-gummy" id="RationalUP">2.4 The Rational Unified Process</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Rational.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>The Rational Unified Process (RUP) (Krutchen, 2003) is an example of a modern
          process model that has been derived from work on the UML and the associated Unified
          Software Development Process (Rumbaugh, et al., 1999; Arlow and Neustadt, 2005).
          I have included a description here, as it is a good example of a hybrid process model.
          It brings together elements from all of the generic process models (Section 2.1), illustrates good practice in specification and design (Section 2.2) and supports prototyping
          and incremental delivery (Section 2.3).</p>
          <br><p class="indent-0">The RUP recognizes that conventional process models present a single view of
          the process. In contrast, the RUP is normally described from three perspectives:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            A <strong>dynamic perspective</strong>, which shows the phases of the model over time.</li>
        <li>
            A <strong>static perspective</strong>, which shows the process activities that are enacted.</li>
        <li>
            A <strong>practice perspective</strong>, which suggests good practices to be used during the process.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>Most descriptions of the RUP attempt to combine the static and dynamic perspectives in a single diagram (Krutchen, 2003). I think that makes the process harder to
          understand, so I use separate descriptions of each of these perspectives</p>
          <br><p>The RUP is a phased model that identifies four discrete phases in the software
          process. However, unlike the waterfall model where phases are equated with process
          activities, the phases in the RUP are more closely related to business rather than
          technical concerns. Figure 2.11 shows the phases in the RUP.</p>
          <br><p class="indent-0">These are:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Inception</strong> The goal of the inception phase is to establish a business case for the
            system. You should identify all external entities (people and systems) that will interact with the system and define these interactions. You then use this information to assess the contribution that the system makes to the business. If this
            contribution is minor, then the project may be cancelled after this phase.</li>
        <li>
            <strong>Elaboration</strong> The goals of the elaboration phase are to develop an understanding
            of the problem domain, establish an architectural framework for the system,
            develop the project plan, and identify key project risks. On completion of this
            phase you should have a requirements model for the system, which may be a set
            of UML use-cases, an architectural description, and a development plan for the
            software.</li>
        <li>
            <strong>Construction</strong> The construction phase involves system design, programming, and
            testing. Parts of the system are developed in parallel and integrated during this
            phase. On completion of this phase, you should have a working software system
            and associated documentation that is ready for delivery to users.</li>
        <li>
            <strong>Transition</strong> The final phase of the RUP is concerned with moving the system
            from the development community to the user community and making it work in
            a real environment. This is something that is ignored in most software process
            models but is, in fact, an expensive and sometimes problematic activity. On
            completion of this phase, you should have a documented software system that is
            working correctly in its operational environment.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>Iteration within the RUP is supported in two ways. Each phase may be enacted in
          an iterative way with the results developed incrementally. In addition, the whole set
          of phases may also be enacted incrementally, as shown by the looping arrow from
          Transition to Inception in Figure 2.12.</p>
          <br><p>The static view of the RUP focuses on the activities that take place during the
          development process. These are called workflows in the RUP description. There are
          six core process workflows identified in the process and three core supporting workflows. The RUP has been designed in conjunction with the UML, so the workflow
          description is oriented around associated UML models such as sequence models,
          object models, etc. The core engineering and support workflows are described in
          Figure 2.13.</p>
        </article>
        <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Workflow.png" 
            alt="Software Process Diagram"
            class="c2img" />
        </article>
        <article class="c2text sour-gummy">
          <p>The advantage in presenting dynamic and static views is that phases of the development process are not associated with specific workflows. In principle at least, all
          of the RUP workflows may be active at all stages of the process. In the early phases
          of the process, most effort will probably be spent on workflows such as business
          modelling and requirements and, in the later phases, in testing and deployment.</p>
          <br><p class="indent-0">The practice perspective on the RUP describes good software engineering practices that are recommended for use in systems development. Six fundamental best
          practices are recommended:</p>
        </article>
        <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
        <li>
            <strong>Develop software iteratively</strong> Plan increments of the system based on customer
            priorities and develop the highest-priority system features early in the development process.</li>
        <li>
            <strong>Manage requirements</strong> Explicitly document the customer’s requirements and
            keep track of changes to these requirements. Analyze the impact of changes on
            the system before accepting them.</li>
        <li>
            <strong>Use component-based architectures</strong> Structure the system architecture into components, as discussed earlier in this chapter.</li>
        <li>
            <strong>Visually model</strong> software Use graphical UML models to present static and
            dynamic views of the software.</li>
        <li>
            <strong>Verify software quality</strong> Ensure that the software meets the organizational quality
            standards.</li>
        <li>
            <strong>Control changes to software</strong> Manage changes to the software using a change
            management system and configuration management procedures and tools.</li>
        </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>The RUP is not a suitable process for all types of development, e.g., embedded
          software development. However, it does represent an approach that potentially combines the three generic process models discussed in Section 2.1. The most important
          innovations in the RUP are the separation of phases and workflows, and the recognition that deploying software in a user’s environment is part of the process. Phases are
          dynamic and have goals. Workflows are static and are technical activities that are not
          associated with a single phase but may be used throughout the development to
          achieve the goals of each phase.</p>
        </article>
    </section>
    <div class="c2grid-sections">
    <section>
      <h1 class="c2h12 sour-gummy" id="Key">K E Y P O I N T S</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Key.png" alt="Software Process Diagram" class="c2img" />
      </article>
    </section>

    <section>
      <h1 class="c2h12 sour-gummy" id="FR">F U R T H E R &nbsp; R E A D I N G</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Reading.png" alt="Software Process Diagram" class="c2img" />
      </article>
    </section>

    <section>
      <h1 class="c2h12 sour-gummy" id="Exercises">E X E R C I S E S</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Exercises.png" alt="Software Process Diagram" class="c2img" />
      </article>
    </section>

    <section>
      <h1 class="c2h12 sour-gummy" id="Ref">R E F E R E N C E S</h1>
      <article class="flex justify-center my-6 pt-2">
        <img src="/Pictures/Ref.png" alt="Software Process Diagram" class="c2img" />
      </article>
    </section>
  </div>

  </main>

<footer class="bg-opacity-80 c2footer">
  <div class="c2footer2">

    <a href="https://www.facebook.com/erick.carenan.1/" target="_blank" aria-label="Facebook">
      <img src="/Pictures/facebook.png" alt="Facebook"
        class="c2icon">
    </a>

    <a href="https://www.instagram.com/erckcrnn?igsh=cGU0MHhmN2t6b2d4" target="_blank" aria-label="Instagram">
      <img src="/Pictures/instagram.png" alt="Instagram"
        class="c2icon">
    </a>

    <a href="mailto:23-14945@g.batstate-u.edu.ph" aria-label="Email">
      <img src="/Pictures/mail.png" alt="Email"
        class="c2icon">
    </a>

    <a href="tel:+63XXXXXXXXXX" aria-label="Telephone">
      <img src="/Pictures/telephone.png" alt="Telephone"
        class="c2icon">
    </a>
  </div>

  <p class="text-xs sm:c2text sour-gummy-sm md:c2text sour-gummy-base lg:text-lg xl:text-xl text-gray-800 font-medium tracking-wide">
    © 2025 Software Engineering. All rights reserved.
  </p>
</footer>




</body>
</html>
