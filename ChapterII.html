<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sample Website</title>
    <link rel="stylesheet" href="./src/output.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Sour+Gummy:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="c2body">
    <header class="c2header bg-[#C8AE7E] bg-opacity-90">
      <div href="index.html" class="flex items-center space-x-3">
        <a class="flex items-center space-x-3" aria-label="Home">
          <img
            src="./Pictures/software-development.png"
            alt="Logo"
            class="c2logo"
          />
          <h1 class="c2title sour-gummy">Software Engineering</h1>
        </a>
      </div>

      <nav class="relative mt-2 sm:mt-0" aria-label="Chapter Navigation">
        <details class="group">
          <summary class="c2chapter2 sour-gummy">Chapter 2</summary>

          <ul class="c2ul sour-gummy">
            <li>
              <a href="#SoftwareP" class="font-bold c2list"
                >2.0 Software Process</a
              >
            </li>
            <li>
              <a href="#SoftwarePM" class="font-bold c2list"
                >2.1 Software Process Models</a
              >
            </li>
            <li>
              <a href="#Waterfall" class="c2list"
                >2.1.1 The Waterfall Development</a
              >
            </li>
            <li>
              <a href="#Incremental" class="c2list"
                >2.1.2 Incremental Development</a
              >
            </li>
            <li>
              <a href="#Reuse" class="c2list"
                >2.1.3 Reuse-Oriented Software Engineering</a
              >
            </li>
            <li>
              <a href="#Activities" class="font-bold c2list"
                >2.2 Process Activities</a
              >
            </li>
            <li>
              <a href="#SoftwareSpec" class="c2list"
                >2.2.1 Software Specification</a
              >
            </li>
            <li>
              <a href="#SoftwareDI" class="c2list"
                >2.2.2 Software Design and Implementation</a
              >
            </li>
            <li>
              <a href="#SoftwareV" class="c2list">2.2.3 Software Validation</a>
            </li>
            <li>
              <a href="#SoftwareE" class="c2list">2.2.4 Software Evolution</a>
            </li>
            <li>
              <a href="#Coping" class="font-bold c2list"
                >2.3 Coping With Change</a
              >
            </li>
            <li><a href="#Proto" class="c2list">2.3.1 Prototyping</a></li>
            <li>
              <a href="#IncreD" class="c2list">2.3.2 Incremental Delivery</a>
            </li>
            <li>
              <a href="#Boehm's" class="c2list"
                >2.3.3 The Boehm's Spiral Model</a
              >
            </li>
            <li>
              <a href="#RationalUP" class="font-bold c2list"
                >2.4 The Rational Unified Process</a
              >
            </li>
            <li><a href="#Key" class="font-bold c2list">Keypoints</a></li>
            <li><a href="#FR" class="font-bold c2list">Further Readings</a></li>
            <li><a href="#Exercises" class="font-bold c2list">Exercises</a></li>
            <li><a href="#Ref" class="font-bold c2list">References</a></li>
          </ul>
        </details>
      </nav>
    </header>

    <main
      class="flex-1 p-4 text-[#996515] sm:pl-9 sm:pr-9 md:pl-12 md:pr-12 lg:pl-15 lg:pr-15"
    >
      <section>
        <h1 class="c2h1 sour-gummy" id="SoftwareP">2.0 Software Processes</h1>
        <article class="c2text sour-gummy">
          <p>
            A <strong>Software Process</strong> is a set of related activities
            that leads to the production of a software product. These activities
            may involve the development of software from scratch in a standard
            programming language like Java or C. However, business applications
            are not necessarily developed in this way. New business software is
            now often developed by extending and modifying existing systems or
            by configuring and integrating off-the-shelf software or system
            components.
          </p>
          <br />
          <p>
            There are many different software processes but all must include
            four activities that are fundamental to software engineering:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Software specification:</strong> The functionality of the
              software and constraints on its operation must be defined.
            </li>
            <li>
              <strong>Software design and implementation:</strong> The software
              to meet the specification must be produced.
            </li>
            <li>
              <strong>Software validation:</strong> The software must be
              validated to ensure that it does what the customer wants.
            </li>
            <li>
              <strong>Software evolution:</strong> The software must evolve to
              meet changing customer needs.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            In some form, these activities are part of all software processes.
            In practice, of course, they are complex activities in themselves
            and include sub-activities such as requirements validation,
            architectural design, unit testing, etc. There are also supporting
            process activities such as documentation and software configuration
            management.
          </p>
          <br />
          <p>
            When we describe and discuss processes, we usually talk about the
            activities in these processes such as specifying a data model,
            designing a user interface, etc., and the ordering of these
            activities. However, as well as activities, process descriptions may
            also include:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Products</strong>, which are the outcomes of a process
              activity. For example, the outcome of the activity of
              architectural design may be a model of the software architecture.
            </li>
            <li>
              <strong>Roles</strong>, which reflect the responsibilities of the
              people involved in the process. Examples of roles are project
              manager, configuration manager, programmer, etc.
            </li>
            <li>
              <strong>Pre- and post-conditions</strong>, which are statements
              that are true before and after a process activity has been enacted
              or a product produced. For example, before architectural design
              begins, a pre-condition may be that all requirements have been
              approved by the customer; after this activity is finished, a
              post-condition might be that the UML models describing the
              architecture have been reviewed.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            <strong>Software processes</strong> are complex and, like all
            intellectual and creative processes, rely on people making decisions
            and judgments. There is no ideal process and most organizations have
            developed their own software development processes. Processes have
            evolved to take advantage of the capabilities of the people in an
            organization and the specific characteristics of the systems that
            are being developed.
          </p>
          <br />
          <p>
            For some systems, such as critical systems, a very structured
            development process is required. For business systems, with rapidly
            changing requirements, a less formal, flexible process is likely to
            be more effective.
          </p>
          <br />
          <p>
            Sometimes, software processes are categorized as either plan-driven
            or agile processes. Plan-driven processes are processes where all of
            the process activities are planned in advance and progress is
            measured against this plan. In agile processes, which I discuss in
            Chapter 3, planning is incremental and it is easier to change the
            process to reflect changing customer requirements.
            <br /><br /><strong>As Boehm and Turner (2003)</strong> discuss,
            each approach is suitable for different types of software.
            Generally, you need to find a balance between plan-driven and agile
            processes.
          </p>
          <br />
          <p>
            Although there is no ‘ideal’ software process, there is scope for
            improving the software process in many organizations. Processes may
            include outdated techniques or may not take advantage of the best
            practice in industrial software engineering. Indeed, many
            organizations still do not take advantage of software engineering
            methods in their software development.
          </p>
          <br />
          <p>
            Software processes can be improved by process standardization where
            the diversity in software processes across an organization is
            reduced. This leads to improved communication and a reduction in
            training time, and makes automated process support more economical.
            Standardization is also an important first step in introducing new
            software engineering methods and techniques and good software
            engineering practice. I discuss software process improvement in more
            detail in Chapter 26.
          </p>
        </article>
      </section>
      <h1 class="c2h12 sour-gummy" id="SoftwarePM">
        2.1 Software Process Models
      </h1>
      <article class="c2text sour-gummy">
        <p>
          As I explained in Chapter 1, a software process model is a simplified
          representation of a software process. Each process model represents a
          process from a particular perspective, and thus provides only partial
          information about that process. For example, a process activity model
          shows the activities and their sequence but may not show the roles of
          the people involved in these activities. In this section, I introduce
          a number of very general process models (sometimes called ‘process
          paradigms’) and present these from an architectural perspective. That
          is, we see the framework of the process but not the details of
          specific activities.
        </p>
        <br />
        <p>
          These generic models are not definitive descriptions of software
          processes. Rather, they are abstractions of the process that can be
          used to explain different approaches to software development. You can
          think of them as process frameworks that may be extended and adapted
          to create more specific software engineering processes.
        </p>
        <br />
        <p class="indent-0">The process models that I cover here are:</p>
      </article>
      <article class="tracking-widest pl-8">
        <ol class="c2ol sour-gummy">
          <li>
            The <strong>Waterfall Model</strong> This takes the fundamental
            process activities of specification, development, validation, and
            evolution and represents them as separate process phases such as
            requirements specification, software design, implementation,
            testing, and so on.
          </li>
          <li>
            <strong>Incremental Development</strong> This approach interleaves
            the activities of specification, development, and validation. The
            system is developed as a series of versions (increments), with each
            version adding functionality to the previous version.
          </li>
          <li>
            <strong>Reuse-oriented Software Engineering</strong> This approach
            is based on the existence of a significant number of reusable
            components. The system development process focuses on integrating
            these components into a system rather than developing them from
            scratch.
          </li>
        </ol>
      </article>
      <article class="c2text sour-gummy">
        <p>
          These models are not mutually exclusive and are often used together,
          especially for large systems development. For large systems, it makes
          sense to combine some of the best features of the waterfall and the
          incremental development models. <br />You need to have information
          about the essential system requirements to design a software
          architecture to support these requirements. You cannot develop this
          incrementally. Sub-systems within a larger system may be developed
          using different approaches. <br />Parts of the system that are well
          understood can be specified and developed using a waterfall-based
          process. Parts of the system which are difficult to specify in
          advance, such as the user interface, should always be developed using
          an incremental approach.
        </p>
      </article>
      <section>
        <h1 class="c2h12 sour-gummy" id="Waterfall">
          2.1.1 The Waterfall Model
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/waterfall.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            The first published model of the software development process was
            derived from more general system engineering processes (Royce,
            1970). This model is illustrated in Figure 2.1. Because of the
            cascade from one phase to another, this model is known as the
            ‘waterfall model’ or software life cycle. <br /><br />The waterfall
            model is an example of a plan-driven process—in principle, you must
            plan and schedule all of the process activities before starting work
            on them.
          </p>
          <br />
          <p class="indent-0">
            The principal stages of the waterfall model directly reflect the
            fundamental development activities:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Requirements analysis and definition</strong> The system’s
              services, constraints, and goals are established by consultation
              with system users. They are then defined in detail and serve as a
              system specification.
            </li>
            <li>
              <strong>System and software design</strong> The systems design
              process allocates the requirements to either hardware or software
              systems by establishing an overall system architecture. Software
              design involves identifying and describing the fundamental
              software system abstractions and their relationships.
            </li>
            <li>
              <strong>Implementation and unit testing</strong> During this
              stage, the software design is realized as a set of programs or
              program units. Unit testing involves verifying that each unit
              meets its specification.
            </li>
            <li>
              <strong>Integration and system testing</strong> The individual
              program units or programs are integrated and tested as a complete
              system to ensure that the software requirements have been met.
              After testing, the software system is delivered to the customer.
            </li>
            <li>
              <strong>Operation and maintenance</strong> Normally (although not
              necessarily), this is the longest life cycle phase. The system is
              installed and put into practical use. Maintenance involves
              correcting errors which were not discovered in earlier stages of
              the life cycle, improving the implementation of system units and
              enhancing the system’s services as new requirements are
              discovered.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            The waterfall model is consistent with other engineering process
            models and documentation is produced at each phase. This makes the
            process visible so managers can monitor progress against the
            development plan. Its major problem is the inflexible partitioning
            of the project into distinct stages. Commitments must be made at an
            early stage in the process, which makes it difficult to respond to
            changing customer requirements.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="Incremental">
          2.1.2 Incremental Development
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/incremental.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            Incremental development is based on the idea of developing an
            initial implementation, exposing this to user comment and evolving
            it through several versions until an adequate system has been
            developed (Figure 2.2). Specification, development, and validation
            activities are interleaved rather than separate, with rapid feedback
            across activities.
          </p>
          <br />
          <p>
            Incremental software development, which is a fundamental part of
            agile approaches, is better than a waterfall approach for most
            business, e-commerce, and personal systems. Incremental development
            reflects the way that we solve problems. <br /><br />We rarely work
            out a complete problem solution in advance but move toward a
            solution in a series of steps, backtracking when we realize that we
            have made a mistake. By developing the software incrementally, it is
            cheaper and easier to make changes in the software as it is being
            developed.
          </p>
          <br />
          <p>
            Each increment or version of the system incorporates some of the
            functionality that is needed by the customer. Generally, the early
            increments of the system include the most important or most urgently
            required functionality. This means that the customer can evaluate
            the system at a relatively early stage in the development to see if
            it delivers what is required. If not, then only the current
            increment has to be changed and, possibly, new functionality defined
            for later increments.
          </p>
          <br />
          <p class="indent-0">
            Incremental development has three important benefits, compared to
            the waterfall model:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              The cost of accommodating changing customer requirements is
              reduced. The amount of analysis and documentation that has to be
              redone is much less than is required with the waterfall model.
            </li>
            <li>
              It is easier to get customer feedback on the development work that
              has been done. Customers can comment on demonstrations of the
              software and see how much has been implemented. Customers find it
              difficult to judge progress from software design documents.
            </li>
            <li>
              More rapid delivery and deployment of useful software to the
              customer is possible, even if all of the functionality has not
              been included. Customers are able to use and gain value from the
              software earlier than is possible with a waterfall process.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            Incremental development in some form is now the most common approach
            for the development of application systems. This approach can be
            either plan-driven, agile, or, more usually, a mixture of these
            approaches. In a plan-driven approach, the system increments are
            identified in advance; if an agile approach is adopted, the early
            increments are identified but the development of later increments
            depends on progress and customer priorities.
          </p>
          <br />
          <p class="indent-0">
            From a management perspective, the incremental approach has two
            problems:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              The process is not visible. Managers need regular deliverables to
              measure progress. If systems are developed quickly, it is not
              cost-effective to produce documents that reflect every version of
              the system.
            </li>
            <li>
              System structure tends to degrade as new increments are added.
              Unless time and money is spent on refactoring to improve the
              software, regular change tends to corrupt its structure.
              Incorporating further software changes becomes increasingly
              difficult and costly.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            The problems of incremental development become particularly acute
            for large, complex, long-lifetime systems, where different teams
            develop different parts of the system. Large systems need a stable
            framework or architecture and the responsibilities of the different
            teams working on parts of the system need to be clearly defined with
            respect to that architecture. This has to be planned in advance
            rather than developed incrementally.
          </p>
          <br />
          <p>
            You can develop a system incrementally and expose it to customers
            for comment, without actually delivering it and deploying it in the
            customer’s environment. Incremental delivery and deployment means
            that the software is used in real, operational processes. This is
            not always possible as experimenting with new software can disrupt
            normal business processes. I discuss the advantages and
            disadvantages of incremental delivery in Section 2.3.2.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="Reuse">
          2.1.3 Reuse-oriented Software Engineering
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/reuse.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            In the majority of software projects, there is some software reuse.
            This often happens informally when people working on the project
            know of designs or code that are similar to what is required. They
            look for these, modify them as needed, and incorporate them into
            their system.
          </p>
          <br />
          <p>
            This informal reuse takes place irrespective of the development
            process that is used. However, in the 21st century, software
            development processes that focus on the reuse of existing software
            have become widely used. Reuse-oriented approaches rely on a large
            base of reusable software components and an integrating framework
            for the composition of these components. Sometimes, these components
            are systems in their own right (COTS or commercial off-the-shelf
            systems) that may provide specific functionality such as word
            processing or a spreadsheet.
          </p>
          <br />
          <p>
            A general process model for reuse-based development is shown in
            Figure 2.3. Although the initial requirements specification stage
            and the validation stage are comparable with other software
            processes, the intermediate stages in a reuseoriented process are
            different.
          </p>
          <br />
          <p class="indent-0">These stages are:</p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              Component analysis Given the requirements specification, a search
              is made for components to implement that specification. Usually,
              there is no exact match and the components that may be used only
              provide some of the functionality required.
            </li>
            <li>
              Requirements modification During this stage, the requirements are
              analyzed using information about the components that have been
              discovered. They are then modified to reflect the available
              components. Where modifications are impossible, the component
              analysis activity may be re-entered to search for alternative
              solutions.
            </li>
            <li>
              System design with reuse During this phase, the framework of the
              system is designed or an existing framework is reused. The
              designers take into account the components that are reused and
              organize the framework to cater for this. Some new software may
              have to be designed if reusable components are not available.
            </li>
            <li>
              Development and integration Software that cannot be externally
              procured is developed, and the components and COTS systems are
              integrated to create the new system. System integration, in this
              model, may be part of the development process rather than a
              separate activity.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p class="indent-0">
            There are three types of software component that may be used in a
            reuse-oriented process:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              Web services that are developed according to service standards and
              which are available for remote invocation.
            </li>
            <li>
              Collections of objects that are developed as a package to be
              integrated with a component framework such as .NET or J2EE.
            </li>
            <li>
              Stand-alone software systems that are configured for use in a
              particular environment.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            Reuse-oriented software engineering has the obvious advantage of
            reducing the amount of software to be developed and so reducing cost
            and risks. It usually also leads to faster delivery of the software.
            However, requirements compromises are inevitable and this may lead
            to a system that does not meet the real needs of users. Furthermore,
            some control over the system evolution is lost as new versions of
            the reusable components are not under the control of the
            organization using them.
          </p>
          <br />
          <p>
            Software reuse is very important and I have dedicated several
            chapters in the third part of the book to this topic. General issues
            of software reuse and COTS reuse are covered in Chapter 16,
            component-based software engineering in Chapters 17 and 18, and
            service-oriented systems in Chapter 19.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="Activities">2.2 Process Activities</h1>
        <article class="c2text sour-gummy">
          <p>
            Real software processes are interleaved sequences of technical,
            collaborative, and managerial activities with the overall goal of
            specifying, designing, implementing, and testing a software system.
            <br /><br />Software developers use a variety of different software
            tools in their work. Tools are particularly useful for supporting
            the editing of different types of document and for managing the
            immense volume of detailed information that is generated in a large
            software project.
          </p>
          <br />
          <p>
            The four basic process activities of specification, development,
            validation, and evolution are organized differently in different
            development processes. In the waterfall model, they are organized in
            sequence, whereas in incremental development they are interleaved.
            <br /><br />How these activities are carried out depends on the type
            of software, people, and organizational structures involved. In
            extreme programming, for example, specifications are written on
            cards. Tests are executable and developed before the program itself.
            Evolution may involve substantial system restructuring or
            refactoring.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="SoftwareSpec">
          2.2.1 Software Specification
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/softwareSpec.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            <strong>Software specification</strong> or requirements engineering
            is the process of understanding and defining what services are
            required from the system and identifying the constraints on the
            system’s operation and development. <br /><br /><strong
              >Requirements engineering</strong
            >
            is a particularly critical stage of the software process as errors
            at this stage inevitably lead to later problems in the system design
            and implementation.
          </p>
          <br />
          <p>
            <strong>The requirements engineering process</strong> (Figure 2.4)
            aims to produce an agreed requirements document that specifies a
            system satisfying stakeholder requirements. <br /><br /><strong
              >Requirements</strong
            >
            are usually presented at two levels of detail. End-users and
            customers need a high-level statement of the requirements; system
            developers need a more detailed system specification.
          </p>
          <br />
          <p class="indent-0">
            There are four main activities in the requirements engineering
            process:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Feasibility Study</strong> - An estimate is made of
              whether the identified user needs may be satisfied using current
              software and hardware technologies. The study considers whether
              the proposed system will be cost-effective from a business point
              of view and if it can be developed within existing budgetary
              constraints. A feasibility study should be relatively cheap and
              quick. The result should inform the decision of whether or not to
              go ahead with a more detailed analysis.
            </li>
            <li>
              <strong>Requirements Elicitation and Analysis</strong> - This is
              the process of deriving the system requirements through
              observation of existing systems, discussions with potential users
              and procurers, task analysis, and so on. This may involve the
              development of one or more system models and prototypes. These
              help you understand the system to be specified.
            </li>
            <li>
              <strong>Requirements Specification</strong> - Requirements
              specification is the activity of translating the information
              gathered during the analysis activity into a document that defines
              a set of requirements. Two types of requirements may be included
              in this document. User requirements are abstract statements of the
              system requirements for the customer and end-user of the system;
              system requirements are a more detailed description of the
              functionality to be provided.
            </li>
            <li>
              <strong>Requirements Validation</strong> - This activity checks
              the requirements for realism, consistency, and completeness.
              During this process, errors in the requirements document are
              inevitably discovered. It must then be modified to correct these
              problems.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            Of course, the activities in the requirements process are not simply
            carried out in a strict sequence. Requirements analysis continues
            during definition and specification and new requirements come to
            light throughout the process. <br /><br />Therefore, the activities
            of analysis, definition, and specification are interleaved. In agile
            methods, such as extreme programming, requirements are developed
            incrementally according to user priorities and the elicitation of
            requirements comes from users who are part of the development team.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="SoftwareDI">
          2.2.2 Software design and implementation
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/softwareImp.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            The implementation stage of software development is the process of
            converting a system specification into an executable system. It
            always involves processes of software design and programming but, if
            an incremental approach to development is used, may also involve
            refinement of the software specification.
          </p>
          <br />
          <p>
            A software design is a description of the structure of the software
            to be implemented, the data models and structures used by the
            system, the interfaces between system components and, sometimes, the
            algorithms used. Designers do not arrive at a finished design
            immediately but develop the design iteratively. They add formality
            and detail as they develop their design with constant backtracking
            to correct earlier designs.
          </p>
          <br />
          <p>
            Figure 2.5 is an abstract model of this process showing the inputs
            to the design process, process activities, and the documents
            produced as outputs from this process.
          </p>
          <br />
          <p>
            The diagram suggests that the stages of the design process are
            sequential. In fact, design process activities are interleaved.
            Feedback from one stage to another and consequent design rework is
            inevitable in all design processes.
          </p>
          <br />
          <p>
            Most software interfaces with other software systems. These include
            the operating system, database, middleware, and other application
            systems. These make up the ‘software platform’, the environment in
            which the software will execute. Information about this platform is
            an essential input to the design process, as designers must decide
            how best to integrate it with the software’s environment.
            <br /><br />The requirements specification is a description of the
            functionality the software must provide and its performance and
            dependability requirements. If the system is to process existing
            data, then the description of that data may be included in the
            platform specification; otherwise, the data description must be an
            input to the design process so that the system data organization to
            be defined.
          </p>
          <br />
          <p class="indent-0">
            The activities in the design process vary, depending on the type of
            system being developed. For example, real-time systems require
            timing design but may not include a database so there is no database
            design involved. Figure 2.5 shows four activities that may be part
            of the design process for information systems:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Architectural design</strong>, where you identify the
              overall structure of the system, the principal components
              (sometimes called sub-systems or modules), their relationships,
              and how they are distributed.
            </li>
            <li>
              <strong>Interface design</strong>, where you define the interfaces
              between system components. This interface specification must be
              unambiguous. With a precise interface, a component can be used
              without other components having to know how it is implemented.
              Once interface specifications are agreed, the components can be
              designed and developed concurrently.
            </li>
            <li>
              <strong>Component design</strong>, where you take each system
              component and design how it will operate. This may be a simple
              statement of the expected functionality to be implemented, with
              the specific design left to the programmer. Alternatively, it may
              be a c2list of changes to be made to a reusable component or a
              detailed design model. The design model may be used to
              automatically generate an implementation.
            </li>
            <li>
              <strong>Database design</strong>, where you design the system data
              structures and how these are to be represented in a database.
              Again, the work here depends on whether an existing database is to
              be reused or a new database is to be created.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            The development of a program to implement the system follows
            naturally from the system design processes. Although some classes of
            program, such as safety-critical systems, are usually designed in
            detail before any implementation begins, it is more common for the
            later stages of design and program development to be interleaved.
            <br /><br />Software development tools may be used to generate a
            skeleton program from a design. This includes code to define and
            implement interfaces, and, in many cases, the developer need only
            add details of the operation of each program component.
          </p>
        </article>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/testing.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            Normally, programmers carry out some testing of the code they have
            developed. This often reveals program defects that must be removed
            from the program. This is called debugging. Defect testing and
            debugging are different processes. <br /><br />Testing establishes
            the existence of defects. Debugging is concerned with locating and
            correcting these defects.
          </p>
          <br />
          <p>
            When you are debugging, you have to generate hypotheses about the
            observable behavior of the program then test these hypotheses in the
            hope of finding the fault that caused the output anomaly.
            <br /><br />Testing the hypotheses may involve tracing the program
            code manually. It may require new test cases to localize the
            problem. Interactive debugging tools, which show the intermediate
            values of program variables and a trace of the statements executed,
            may be used to support the debugging process.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="SoftwareV">
          2.2.3 Software Validation
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/Softwareval.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            Software validation or, more generally, verification and validation
            (V&V) is intended to show that a system both conforms to its
            specification and that it meets the expectations of the system
            customer. Program testing, where the system is executed using
            simulated test data, is the principal validation technique.
            <br /><br />Validation may also involve checking processes, such as
            inspections and reviews, at each stage of the software process from
            user requirements definition to program development. Because of the
            predominance of testing, the majority of validation costs are
            incurred during and after implementation.
          </p>
          <br />
          <p>
            Except for small programs, systems should not be tested as a single,
            monolithic unit. Figure 2.6 shows a three-stage testing process in
            which system components are tested then the integrated system is
            tested and, finally, the system is tested with the customer’s data.
            Ideally, component defects are discovered early in the process, and
            interface problems are found when the system is integrated.
          </p>
          <br />
          <p>
            However, as defects are discovered, the program must be debugged and
            this may require other stages in the testing process to be repeated.
            Errors in program components, say, may come to light during system
            testing. The process is therefore an iterative one with information
            being fed back from later stages to earlier parts of the process.
          </p>
          <p class="indent-0">The stages in the testing process are:</p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Development testing</strong> The components making up the
              system are tested by the people developing the system. Each
              component is tested independently, without other system
              components. Components may be simple entities such as functions or
              object classes, or may be coherent groupings of these entities.
              Test automation tools, such as JUnit (Massol and Husted, 2003),
              that can re-run component tests when new versions of the component
              are created, are commonly used.
            </li>
            <li>
              <strong>System testing</strong> System components are integrated
              to create a complete system. This process is concerned with
              finding errors that result from unanticipated interactions between
              components and component interface problems. It is also concerned
              with showing that the system meets its functional and
              non-functional requirements, and testing the emergent system
              properties. For large systems, this may be a multi-stage process
              where components are integrated to form subsystems that are
              individually tested before these sub-systems are themselves
              integrated to form the final system.
            </li>
            <li>
              <strong>Acceptance testing</strong> This is the final stage in the
              testing process before the system is accepted for operational use.
              The system is tested with data supplied by the system customer
              rather than with simulated test data. Acceptance testing may
              reveal errors and omissions in the system requirements definition,
              because the real data exercise the system in different ways from
              the test data. Acceptance testing may also reveal requirements
              problems where the system’s facilities do not really meet the
              user’s needs or the system performance is unacceptable.
            </li>
          </ol>
        </article>
        <article>
          <p>
            Normally, component development and testing processes are
            interleaved. Programmers make up their own test data and
            incrementally test the code as it is developed. This is an
            economically sensible approach, as the programmer knows the
            component and is therefore the best person to generate test cases.
          </p>
          <br />
          <p>
            If an incremental approach to development is used, each increment
            should be tested as it is developed, with these tests based on the
            requirements for that increment. In extreme programming, tests are
            developed along with the requirements before development starts.
            This helps the testers and developers to understand the requirements
            and ensures that there are no delays as test cases are created.
          </p>
          <br />
          <p>
            When a plan-driven software process is used (e.g., for critical
            systems development), testing is driven by a set of test plans. An
            independent team of testers works from these pre-formulated test
            plans, which have been developed from the system specification and
            design. Figure 2.7 illustrates how test plans are the link between
            testing and development activities. This is sometimes called the
            V-model of development (turn it on its side to see the V).
          </p>
          <br />
          <p>
            Acceptance testing is sometimes called ‘alpha testing’. Custom
            systems are developed for a single client. The alpha testing process
            continues until the system developer and the client agree that the
            delivered system is an acceptable implementation of the
            requirements.
          </p>
          <br />
          <p>
            When a system is to be marketed as a software product, a testing
            process called ‘beta testing’ is often used. Beta testing involves
            delivering a system to a number of potential customers who agree to
            use that system. They report problems to the system developers. This
            exposes the product to real use and detects errors that may not have
            been anticipated by the system builders. After this feedback, the
            system is modified and released either for further beta testing or
            for general sale.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="SoftwareE">
          2.2.4 Software Evolution
        </h1>
        <article class="c2text sour-gummy">
          <p>
            The flexibility of software systems is one of the main reasons why
            more and more software is being incorporated in large, complex
            systems. Once a decision has been made to manufacture hardware, it
            is very expensive to make changes to the hardware design. However,
            changes can be made to software at any time during or after the
            system development. Even extensive changes are still much cheaper
            than corresponding changes to system hardware.
          </p>
          <br />
          <p>
            Historically, there has always been a split between the process of
            software development and the process of software evolution (software
            maintenance). People think of software development as a creative
            activity in which a software system is developed from an initial
            concept through to a working system. However, they sometimes think
            of software maintenance as dull and uninteresting. Although the
            costs of maintenance are often several times the initial development
            costs, maintenance processes are sometimes considered to be less
            challenging than original software development.
          </p>
          <br />
          <p>
            This distinction between development and maintenance is increasingly
            irrelevant. Hardly any software systems are completely new systems
            and it makes much more sense to see development and maintenance as a
            continuum. Rather than two separate processes, it is more realistic
            to think of software engineering as an evolutionary process (Figure
            2.8) where software is continually changed over its lifetime in
            response to changing requirements and customer needs.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="Coping">2.3 Coping with Change</h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/Evolution.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            Change is inevitable in all large software projects. The system
            requirements change as the business procuring the system responds to
            external pressures and management priorities change. As new
            technologies become available, new design and implementation
            possibilities emerge. Therefore whatever software process model is
            used, it is essential that it can accommodate changes to the
            software being developed.
          </p>
          <br />
          <p>
            Change adds to the costs of software development because it usually
            means that work that has been completed has to be redone. This is
            called rework. For example, if the relationships between the
            requirements in a system have been analyzed and new requirements are
            then identified, some or all of the requirements analysis has to be
            repeated. It may then be necessary to redesign the system to deliver
            the new requirements, change any programs that have been developed,
            and re-test the system.
          </p>
          <br />
          <p class="indent-0">
            There are two related approaches that may be used to reduce the
            costs of rework:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Change avoidance</strong>, where the software process
              includes activities that can anticipate possible changes before
              significant rework is required. For example, a prototype system
              may be developed to show some key features of the system to
              customers. They can experiment with the prototype and refine their
              requirements before committing to high software production costs
            </li>
            <li>
              <strong>Change tolerance</strong>, where the process is designed
              so that changes can be accommodated at relatively low cost. This
              normally involves some form of incremental development. Proposed
              changes may be implemented in increments that have not yet been
              developed. If this is impossible, then only a single increment (a
              small part of the system) may have to be altered to incorporate
              the change.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p class="indent-0">
            In this section, I discuss two ways of coping with change and
            changing system requirements. These are:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>System prototyping</strong>, where a version of the system
              or part of the system is developed quickly to check the customer’s
              requirements and the feasibility of some design decisions. This
              supports change avoidance as it allows users to experiment with
              the system before delivery and so refine their requirements. The
              number of requirements change proposals made after delivery is
              therefore likely to be reduced.
            </li>
            <li>
              <strong>Incremental delivery</strong>, where system increments are
              delivered to the customer for comment and experimentation. This
              supports both change avoidance and change tolerance. It avoids the
              premature commitment to requirements for the whole system and
              allows changes to be incorporated into later increments at
              relatively low cost.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            The notion of refactoring, namely improving the structure and
            organization of a program, is also an important mechanism that
            supports change tolerance. I discuss this in Chapter 3, which covers
            agile methods.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="Proto">2.3.1 Prototyping</h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/Proto.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            A prototype is an initial version of a software system that is used
            to demonstrate concepts, try out design options, and find out more
            about the problem and its possible solutions. Rapid, iterative
            development of the prototype is essential so that costs are
            controlled and system stakeholders can experiment with the prototype
            early in the software process.
          </p>
          <br />
          <p class="indent-0">
            A software prototype can be used in a software development process
            to help anticipate changes that may be required:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              In the requirements engineering process, a prototype can help with
              the elicitation and validation of system requirements.
            </li>
            <li>
              In the system design process, a prototype can be used to explore
              particular software solutions and to support user interface
              design.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            System prototypes allow users to see how well the system supports
            their work. They may get new ideas for requirements, and find areas
            of strength and weakness in the software. <br /><br />They may then
            propose new system requirements. Furthermore, as the prototype is
            developed, it may reveal errors and omissions in the requirements
            that have been proposed. <br /><br />A function described in a
            specification may seem useful and well defined. However, when that
            function is combined with other functions, users often find that
            their initial view was incorrect or incomplete. The system
            specification may then be modified to reflect their changed
            understanding of the requirements
          </p>
          <br />
          <p>
            A system prototype may be used while the system is being designed to
            carry out design experiments to check the feasibility of a proposed
            design. <br /><br />For example, a database design may be prototyped
            and tested to check that it supports efficient data access for the
            most common user queries. <br /><br />Prototyping is also an
            essential part of the user interface design process. Because of the
            dynamic nature of user interfaces, textual descriptions and diagrams
            are not good enough for expressing the user interface requirements.
            Therefore, rapid prototyping with end-user involvement is the only
            sensible way to develop graphical user interfaces for software
            systems.
          </p>
          <br />
          <p>
            A process model for prototype development is shown in Figure 2.9.
            The objectives of prototyping should be made explicit from the start
            of the process. These may be to develop a system to prototype the
            user interface, to develop a system to validate functional system
            requirements, or to develop a system to demonstrate the feasibility
            of the application to managers. <br /><br />The same prototype
            cannot meet all objectives. If the objectives are left unstated,
            management or end-users may misunderstand the function of the
            prototype. Consequently, they may not get the benefits that they
            expected from the prototype development.
          </p>
          <br />
          <p>
            The next stage in the process is to decide what to put into and,
            perhaps more importantly, what to leave out of the prototype system.
            To reduce prototyping costs and accelerate the delivery schedule,
            you may leave some functionality out of the prototype.
            <br /><br />You may decide to relax non-functional requirements such
            as response time and memory utilization. Error handling and
            management may be ignored unless the objective of the prototype is
            to establish a user interface. Standards of reliability and program
            quality may be reduced.
          </p>
          <br />
          <p>
            The final stage of the process is prototype evaluation. Provision
            must be made during this stage for user training and the prototype
            objectives should be used to derive a plan for evaluation. Users
            need time to become comfortable with a new system and to settle into
            a normal pattern of usage. Once they are using the system normally,
            they then discover requirements errors and omissions.
          </p>
          <br />
          <p>
            A general problem with prototyping is that the prototype may not
            necessarily be used in the same way as the final system. The tester
            of the prototype may not be typical of system users. <br /><br />The
            training time during prototype evaluation may be insufficient. If
            the prototype is slow, the evaluators may adjust their way of
            working and avoid those system features that have slow response
            times. When provided with better response in the final system, they
            may use it in a different way.
          </p>
          <br />
          <p class="indent-0">
            Developers are sometimes pressured by managers to deliver throwaway
            prototypes, particularly when there are delays in delivering the
            final version of the software. However, this is usually unwise:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              It may be impossible to tune the prototype to meet non-functional
              requirements, such as performance, security, robustness, and
              reliability requirements, which were ignored during prototype
              development.
            </li>
            <li>
              Rapid change during development inevitably means that the
              prototype is undocumented. The only design specification is the
              prototype code. This is not good enough for long-term maintenance.
            </li>
            <li>
              The changes made during prototype development will probably have
              degraded the system structure. The system will be difficult and
              expensive to maintain.
            </li>
            <li>
              Organizational quality standards are normally relaxed for
              prototype development.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            Prototypes do not have to be executable to be useful. Paper-based
            mock-ups of the system user interface (Rettig, 1994) can be
            effective in helping users refine an interface design and work
            through usage scenarios. <br /><br />These are very cheap to develop
            and can be constructed in a few days. An extension of this technique
            is a Wizard of Oz prototype where only the user interface is
            developed. Users interact with this interface but their requests are
            passed to a person who interprets them and outputs the appropriate
            response.
          </p>
        </article>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="IncreD">2.3.2 Incremental delivery</h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/Incred.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            Incremental delivery (Figure 2.10) is an approach to software
            development where some of the developed increments are delivered to
            the customer and deployed for use in an operational environment.
            <br /><br />In an incremental delivery process, customers identify,
            in outline, the services to be provided by the system. They identify
            which of the services are most important and which are least
            important to them. A number of delivery increments are then defined,
            with each increment providing a sub-set of the system functionality.
            The allocation of services to increments depends on the service
            priority, with the highest-priority services implemented and
            delivered first.
          </p>
          <br />
          <p>
            Once the system increments have been identified, the requirements
            for the services to be delivered in the first increment are defined
            in detail and that increment is developed. During development,
            further requirements analysis for later increments can take place
            but requirements changes for the current increment are not accepted.
          </p>
          <br />
          <p>
            Once an increment is completed and delivered, customers can put it
            into service. This means that they take early delivery of part of
            the system functionality. They can experiment with the system and
            this helps them clarify their requirements for later system
            increments. As new increments are completed, they are integrated
            with existing increments so that the system functionality improves
            with each delivered increment.
          </p>
          <br />
          <p class="indent-0">
            Incremental delivery has a number of advantages:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              Customers can use the early increments as prototypes and gain
              experience that informs their requirements for later system
              increments. Unlike prototypes, these are part of the real system
              so there is no re-learning when the complete system is available.
            </li>
            <li>
              Customers do not have to wait until the entire system is delivered
              before they can gain value from it. The first increment satisfies
              their most critical requirements so they can use the software
              immediately.
            </li>
            <li>
              The process maintains the benefits of incremental development in
              that it should be relatively easy to incorporate changes into the
              system.
            </li>
            <li>
              As the highest-priority services are delivered first and
              increments then integrated, the most important system services
              receive the most testing. This means that customers are less
              likely to encounter software failures in the most important parts
              of the system.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p class="indent-0">
            However, there are problems with incremental delivery:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              Most systems require a set of basic facilities that are used by
              different parts of the system. As requirements are not defined in
              detail until an increment is to be implemented, it can be hard to
              identify common facilities that are needed by all increments.
            </li>
            <li>
              Iterative development can also be difficult when a replacement
              system is being developed. Users want all of the functionality of
              the old system and are often unwilling to experiment with an
              incomplete new system. Therefore, getting useful customer feedback
              is difficult.
            </li>
            <li>
              The essence of iterative processes is that the specification is
              developed in conjunction with the software. However, this
              conflicts with the procurement model of many organizations, where
              the complete system specification is part of the system
              development contract. In the incremental approach, there is no
              complete system specification until the final increment is
              specified. This requires a new form of contract, which large
              customers such as government agencies may find difficult to
              accommodate.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            There are some types of system where incremental development and
            delivery is not the best approach. These are very large systems
            where development may involve teams working in different locations,
            some embedded systems where the software depends on hardware
            development and some critical systems where all the requirements
            must be analyzed to check for interactions that may compromise the
            safety or security of the system.
          </p>
          <br />
          <p>
            These systems, of course, suffer from the same problems of uncertain
            and changing requirements. Therefore, to address these problems and
            get some of the benefits of incremental development, a process may
            be used in which a system prototype is developed iteratively and
            used as a platform for experiments with the system requirements and
            design. With the experience gained from the prototype, definitive
            requirements can then be agreed.
          </p>
        </article>
        <section>
          <h1 class="c2h12 sour-gummy" id="Boehm's">
            2.3.3 Boehm’s spiral model
          </h1>
          <article class="flex justify-center my-6 pt-2">
            <img
              src="/Pictures/boehm.png"
              alt="Software Process Diagram"
              class="c2img"
            />
          </article>
          <article class="c2text sour-gummy">
            <p>
              A risk-driven software process framework (the spiral model) was
              proposed by Boehm (1988). This is shown in Figure 2.11. Here, the
              software process is represented as a spiral, rather than a
              sequence of activities with some backtracking from one activity to
              another. Each loop in the spiral represents a phase of the
              software process. <br /><br />Thus, the innermost loop might be
              concerned with system feasibility, the next loop with requirements
              definition, the next loop with system design, and so on. The
              spiral model combines change avoidance with change tolerance. It
              assumes that changes are a result of project risks and includes
              explicit risk management activities to reduce these risks.
            </p>
            <br />
            <p class="indent-0">
              Each loop in the spiral is split into four sectors:
            </p>
          </article>
          <article class="tracking-widest pl-8">
            <ol class="c2ol sour-gummy">
              <li>
                <strong>Objective setting</strong> Specific objectives for that
                phase of the project are defined. Constraints on the process and
                the product are identified and a detailed management plan is
                drawn up. Project risks are identified. Alternative strategies,
                depending on these risks, may be planned.
              </li>
              <li>
                <strong>Risk assessment and reduction</strong> For each of the
                identified project risks, a detailed analysis is carried out.
                Steps are taken to reduce the risk. For example, if there is a
                risk that the requirements are inappropriate, a prototype system
                may be developed.
              </li>
              <li>
                <strong>Development and validation</strong> After risk
                evaluation, a development model for the system is chosen. For
                example, throwaway prototyping may be the best development
                approach if user interface risks are dominant. If safety risks
                are the main consideration, development based on formal
                transformations may be the most appropriate process, and so on.
                If the main identified risk is sub-system integration, the
                waterfall model may be the best development model to use.
              </li>
              <li>
                <strong>Planning</strong> The project is reviewed and a decision
                made whether to continue with a further loop of the spiral. If
                it is decided to continue, plans are drawn up for the next phase
                of the project.
              </li>
            </ol>
          </article>
          <article class="c2text sour-gummy">
            <p>
              The main difference between the spiral model and other software
              process models is its explicit recognition of risk. A cycle of the
              spiral begins by elaborating objectives such as performance and
              functionality. Alternative ways of achieving these objectives, and
              dealing with the constraints on each of them, are then enumerated.
              Each alternative is assessed against each objective and sources of
              project risk are identified. The next step is to resolve these
              risks by information-gathering activities such as more detailed
              analysis, prototyping, and simulation.
            </p>
            <br />
            <p>
              Once risks have been assessed, some development is carried out,
              followed by a planning activity for the next phase of the process.
              Informally, risk simply means something that can go wrong. For
              example, if the intention is to use a new programming language, a
              risk is that the available compilers are unreliable or do not
              produce sufficiently efficient object code. Risks lead to proposed
              software changes and project problems such as schedule and cost
              overrun, so risk minimization is a very important project
              management activity. Risk management, an essential part of project
              management, is covered in Chapter 22.
            </p>
          </article>
        </section>
      </section>
      <section>
        <h1 class="c2h12 sour-gummy" id="RationalUP">
          2.4 The Rational Unified Process
        </h1>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/Rational.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            The Rational Unified Process (RUP) (Krutchen, 2003) is an example of
            a modern process model that has been derived from work on the UML
            and the associated Unified Software Development Process (Rumbaugh,
            et al., 1999; Arlow and Neustadt, 2005). I have included a
            description here, as it is a good example of a hybrid process model.
            It brings together elements from all of the generic process models
            (Section 2.1), illustrates good practice in specification and design
            (Section 2.2) and supports prototyping and incremental delivery
            (Section 2.3).
          </p>
          <br />
          <p class="indent-0">
            The RUP recognizes that conventional process models present a single
            view of the process. In contrast, the RUP is normally described from
            three perspectives:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              A <strong>dynamic perspective</strong>, which shows the phases of
              the model over time.
            </li>
            <li>
              A <strong>static perspective</strong>, which shows the process
              activities that are enacted.
            </li>
            <li>
              A <strong>practice perspective</strong>, which suggests good
              practices to be used during the process.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            Most descriptions of the RUP attempt to combine the static and
            dynamic perspectives in a single diagram (Krutchen, 2003). I think
            that makes the process harder to understand, so I use separate
            descriptions of each of these perspectives
          </p>
          <br />
          <p>
            The RUP is a phased model that identifies four discrete phases in
            the software process. However, unlike the waterfall model where
            phases are equated with process activities, the phases in the RUP
            are more closely related to business rather than technical concerns.
            Figure 2.11 shows the phases in the RUP.
          </p>
          <br />
          <p class="indent-0">These are:</p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Inception</strong> The goal of the inception phase is to
              establish a business case for the system. You should identify all
              external entities (people and systems) that will interact with the
              system and define these interactions. You then use this
              information to assess the contribution that the system makes to
              the business. If this contribution is minor, then the project may
              be cancelled after this phase.
            </li>
            <li>
              <strong>Elaboration</strong> The goals of the elaboration phase
              are to develop an understanding of the problem domain, establish
              an architectural framework for the system, develop the project
              plan, and identify key project risks. On completion of this phase
              you should have a requirements model for the system, which may be
              a set of UML use-cases, an architectural description, and a
              development plan for the software.
            </li>
            <li>
              <strong>Construction</strong> The construction phase involves
              system design, programming, and testing. Parts of the system are
              developed in parallel and integrated during this phase. On
              completion of this phase, you should have a working software
              system and associated documentation that is ready for delivery to
              users.
            </li>
            <li>
              <strong>Transition</strong> The final phase of the RUP is
              concerned with moving the system from the development community to
              the user community and making it work in a real environment. This
              is something that is ignored in most software process models but
              is, in fact, an expensive and sometimes problematic activity. On
              completion of this phase, you should have a documented software
              system that is working correctly in its operational environment.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            Iteration within the RUP is supported in two ways. Each phase may be
            enacted in an iterative way with the results developed
            incrementally. In addition, the whole set of phases may also be
            enacted incrementally, as shown by the looping arrow from Transition
            to Inception in Figure 2.12.
          </p>
          <br />
          <p>
            The static view of the RUP focuses on the activities that take place
            during the development process. These are called workflows in the
            RUP description. There are six core process workflows identified in
            the process and three core supporting workflows. The RUP has been
            designed in conjunction with the UML, so the workflow description is
            oriented around associated UML models such as sequence models,
            object models, etc. The core engineering and support workflows are
            described in Figure 2.13.
          </p>
        </article>
        <article class="flex justify-center my-6 pt-2">
          <img
            src="/Pictures/Workflow.png"
            alt="Software Process Diagram"
            class="c2img"
          />
        </article>
        <article class="c2text sour-gummy">
          <p>
            The advantage in presenting dynamic and static views is that phases
            of the development process are not associated with specific
            workflows. In principle at least, all of the RUP workflows may be
            active at all stages of the process. In the early phases of the
            process, most effort will probably be spent on workflows such as
            business modelling and requirements and, in the later phases, in
            testing and deployment.
          </p>
          <br />
          <p class="indent-0">
            The practice perspective on the RUP describes good software
            engineering practices that are recommended for use in systems
            development. Six fundamental best practices are recommended:
          </p>
        </article>
        <article class="tracking-widest pl-8">
          <ol class="c2ol sour-gummy">
            <li>
              <strong>Develop software iteratively</strong> Plan increments of
              the system based on customer priorities and develop the
              highest-priority system features early in the development process.
            </li>
            <li>
              <strong>Manage requirements</strong> Explicitly document the
              customer’s requirements and keep track of changes to these
              requirements. Analyze the impact of changes on the system before
              accepting them.
            </li>
            <li>
              <strong>Use component-based architectures</strong> Structure the
              system architecture into components, as discussed earlier in this
              chapter.
            </li>
            <li>
              <strong>Visually model</strong> software Use graphical UML models
              to present static and dynamic views of the software.
            </li>
            <li>
              <strong>Verify software quality</strong> Ensure that the software
              meets the organizational quality standards.
            </li>
            <li>
              <strong>Control changes to software</strong> Manage changes to the
              software using a change management system and configuration
              management procedures and tools.
            </li>
          </ol>
        </article>
        <article class="c2text sour-gummy">
          <p>
            The RUP is not a suitable process for all types of development,
            e.g., embedded software development. However, it does represent an
            approach that potentially combines the three generic process models
            discussed in Section 2.1. The most important innovations in the RUP
            are the separation of phases and workflows, and the recognition that
            deploying software in a user’s environment is part of the process.
            Phases are dynamic and have goals. Workflows are static and are
            technical activities that are not associated with a single phase but
            may be used throughout the development to achieve the goals of each
            phase.
          </p>
        </article>
      </section>
      <div class="c2grid-sections">
        <section>
          <h1 class="c2h12 sour-gummy" id="Key">K E Y P O I N T S</h1>
          <article class="flex justify-center my-6 pt-2">
            <img
              src="/Pictures/Key.png"
              alt="Software Process Diagram"
              class="c2img"
            />
          </article>
        </section>

        <section>
          <h1 class="c2h12 sour-gummy" id="FR">
            F U R T H E R &nbsp; R E A D I N G
          </h1>
          <article class="flex justify-center my-6 pt-2">
            <img
              src="/Pictures/Reading.png"
              alt="Software Process Diagram"
              class="c2img"
            />
          </article>
        </section>

        <section>
          <h1 class="c2h12 sour-gummy" id="Exercises">E X E R C I S E S</h1>
          <article class="flex justify-center my-6 pt-2">
            <img
              src="/Pictures/Exercises.png"
              alt="Software Process Diagram"
              class="c2img"
            />
          </article>
        </section>

        <section>
          <h1 class="c2h12 sour-gummy" id="Ref">R E F E R E N C E S</h1>
          <article class="flex justify-center my-6 pt-2">
            <img
              src="/Pictures/Ref.png"
              alt="Software Process Diagram"
              class="c2img"
            />
          </article>
        </section>
      </div>
    </main>

    <footer class="bg-opacity-80 c2footer">
      <div class="c2footer2">
        <a
          href="https://www.facebook.com/erick.carenan.1/"
          target="_blank"
          aria-label="Facebook"
        >
          <img src="/Pictures/facebook.png" alt="Facebook" class="c2icon" />
        </a>

        <a
          href="https://www.instagram.com/erckcrnn?igsh=cGU0MHhmN2t6b2d4"
          target="_blank"
          aria-label="Instagram"
        >
          <img src="/Pictures/instagram.png" alt="Instagram" class="c2icon" />
        </a>

        <a href="mailto:23-14945@g.batstate-u.edu.ph" aria-label="Email">
          <img src="/Pictures/mail.png" alt="Email" class="c2icon" />
        </a>

        <a href="tel:+63XXXXXXXXXX" aria-label="Telephone">
          <img src="/Pictures/telephone.png" alt="Telephone" class="c2icon" />
        </a>
      </div>

      <p
        class="text-xs sm:c2text sour-gummy-sm md:c2text sour-gummy-base lg:text-lg xl:text-xl text-gray-800 font-medium tracking-wide"
      >
        © 2025 Software Engineering. All rights reserved.
      </p>
    </footer>
  </body>
</html>
